### 火山平台语法手册

#### （封装用户版）

**注意:** 本手册内容普通用户无需掌握,示例如非明确说明均为基于安卓平台.

#### 一. 相关概念、约定和资源:

> **1\.** 火山平台基于面向对象的编程理念构造,支持类的封装、继承、多态,但是在此基础上进行了一些精简,以便能更好地学习和使用.
> 
> **2\.** 火山平台将用户分为**普通**和**封装**用户两种.
> 
> > **普通用户**为正常使用火山平台开发应用软件的用户;
> > 
> > **封装用户**则是可以自行使用火山程序扩展火山平台类库的用户.
> > 
> > 为了屏蔽火山程序对特定目标环境的依赖，火山软件开发平台对每个目标环境提供了对应的封装类库，这种类库是使用火山程序本身进行封装的。  
> > 绝大多数情况下，用户不涉及到类库封装方面的工作，随系统附带的类库已经足够完成通常的应用开发需求。但如果用户觉得不够用或者有其它特别的要求，可以使用火山程序自行修改或扩展类库，此类用户被称为封装用户，所需要掌握的知识在本手册中讲述。学习类库封装的最好实际例子在系统类库，可以查看应用程序项目建立后自动添加进去的"**模块**"过滤器中的内容。

#### 二. 相关术语:

> ##### 1\. 名称:
> 
> > 火山平台中的名称分为以下这些:
> > 
> > **1\. 单名称:**
> > 
> > > 单名称必须以英文字母/下划线字符/汉字字符开头,后面跟随英文字母/下划线字符/数字/汉字字符.如未特殊标注,本文档中所提出的所有"名称"均为单名称.
> > 
> > **2\. 全名称:**
> > 
> > > 以句点字符组合在一起的单名称 称为全名称,如"火山.程序". 单名称可以被认为是全名称的一种(只包括一个单名称的全名称).
> > > 
> > > 实际上,目前只有[包名](#)才使用到由多个单名称组成的全名称.
> > 
> > **3\. 标识符名称:** :
> > 
> > > 必须由两个或多个单词文本组成,首单词必须以英文字母/下划线字符开头,后续单词可以以英文字母/数字/下划线字符开头,单词之间使用句点字符分隔,单词中间的字符只能为英文字母/数字/下划线字符,最后一个单词固定为此标识符的当前版本号数值.
> > > 
> > > 两个标识符,如果其名称部分相同且第一个标识符的版本号大于等于第二个标识符的版本号,则说明第一个标识符能够匹配第二个标识符.
> > > 
> > > 如标识符"cplus.win32.console.1",说明其名称为"cplus.win32.console",版本号为1.
> > 
> > 注意: 火山中的名称对英文字母的大小写敏感,譬如"abc","ABC"所指定的不是同一名称.
> 
> ##### 2\. 立即数
> 
> > 立即数用作表达一个直接的字面数据值,有以下几类:
> > 
> > **1\. 数值立即数:**
> > 
> > > **A.** 十进制整数或小数,小数支持使用科学计数法.
> > > 
> > > **B.** 十六进制整数: "0x"后跟数字0-9或字母A-B(大小写无关). 如: 0x12AC3F
> > > 
> > > **C.** 字符整数值: 使用单引号括住的字符,如'A'.
> > > 
> > > 如果欲强行指定数值的数据类型,可以使用"[强制类型转换](#)"操作符,譬如"(长整数)1",提供了一个数据类型为长整数的数值立即数.
> > > 
> > > 如果某整数的数值超出了整数的最大有效范围,将自动被设定为长整数数据类型. 如: 0x123456789A 将被自动认为是长整数数据类型.
> > 
> > **2\. 逻辑型立即数:** 为真/假.
> > 
> > **3\. 字符串立即数:**
> > 
> > > 为用双引号括住的一段文本,文本内支持使用以下转义符:
> > > 
> > > | | |
> > > |---|---|
> > > |**转义符**|**解释**|
> > > |\\b|退格符|
> > > |\\f|换页符|
> > > |\\r|回车符|
> > > |\\n|换行符|
> > > |\\t|水平制表符|
> > > |\\'|单引号|
> > > |\\"|双引号|
> > > |\\\\|反斜杠|
> > > |\\u|后跟1-4个十六进制字符,为所对应字符的Unicode代码值.|
> > > |\\|后跟1-3个八进制字符,为所对应字符的代码字节值.|
> > > |\\x|后跟1-2个十六进制字符,为所对应字符的代码字节值.|
> > > 
> > > 如: "您好!\\n祖国" 在"您好!"和"祖国"之间通过使用转义符插入了一个换行符.
> > > 
> > > 注意: 在火山视窗平台里面,如果欲达到换行效果,需要插入"\\r\\n"回车和换行两个字符.
> > 
> > **4\. 数组立即数**(只能在提供数组常量/变量初始值时使用):
> > 
> > > 为使用花括号括住的立即数的组合,如: { 1, 2 }, 多维数组可以嵌套,如: { { 1, 2 }, { 3, 4 } }
> > > 
> > > 注意: 多维数组的各维成员数目必须相等,譬如如下格式的数组立即数是不允许的: { { 1, 2 }, { 3 } } ,因为其两个维的成员数目不相等.
> 
> ##### 3\. 数据类型:
> 
> > 数据类型可以为以下两种:
> > 
> > > **A.** [基本数据类型](#);
> > > 
> > > **B.** [用户程序中定义的类](#),称为**类数据类型**;
> > > 
> > > **C.** 数组数据类型
> > > 
> > > > 数组数据类型为基本或类数据类型后面跟随一个或多个数组维定义组成.
> > > > 
> > > > 每个数组维定义由左右中括号("\[\]")组成,如果应用在变量定义上,可以同时在中括号内部加入具体成员数目,表示生成对应的数组变量实例. 如:
> > > > 
> > > > > 单维文本数组数据类型: 文本 \[\]
> > > > > 
> > > > > 多维整数数组数据类型: 整数 \[\] \[\]
> > > > > 
> > > > > 定义具有指定成员数目的整数数组变量: 整数 \[3\], 整数 \[3\]\[3\]

#### 三. 火山程序结构:

> 一个火山程序的构成结构如下:
> 
> 1\. [包定义](#)
> 
> > 1\. [文档嵌入行](#)
> > 
> > 2\. [文档注释行](#)
> > 
> > 3\. [类定义](#)
> > 
> > > 1\. [类嵌入行](#)
> > > 
> > > 2\. [类注释行](#)
> > > 
> > > 3\. [类成员常量](#)
> > > 
> > > 4\. [类成员变量](#)
> > > 
> > > 5\. [类成员方法](#)
> > > 
> > > > 1\. 方法参数
> > > > 
> > > > 2\. [方法局部常量](#)
> > > > 
> > > > 3\. [方法局部变量](#)
> > > > 
> > > > 4\. [语句注释行](#)
> > > > 
> > > > 5\. [语句嵌入行](#)
> > > > 
> > > > 6\. [火山语句行](#)
> 
> 下面是一个火山程序的基本样图(天蓝色文字为说明):
> 
> ![](https://doc.voldp.com/images/structure.png)
> 
> ##### 1\. 包定义:
> 
> > 包名为[全名称](#),一个包内可以包含多个文档注释行/文档嵌入行/类定义.
> > 
> > 包定义成员始终位于源文件的首部而且只能存在一个.
> > 
> > 多个程序文件可以具有相同的包名,此时其中的内容被认为处于同一个包中.
> 
> ##### 2\. 注释
> 
> > 可以使用以下方式定义火山程序中的注释:
> > 
> > > **A.** 任何定义型成员其名称如果以**连续两个'/'字符**引导,说明其处于被注释状态,其以及其中的所有内容(包括直接/间接子成员)在编译时都将被忽略;
> > > 
> > > **B.** 在类外部的程序行,被称为**文档注释行**; 在类内部但是在类方法外部的程序行,被称为**类注释行**;
> > > 
> > > **C.** 在类方法内部可以使用**连续两个'/'字符**引导一段一直到行尾的语句注释文本.
> > 
> > 文档注释行/类注释行/从行首开始的语句注释文本,其尾部如果以一个或多个**减号**/**等号**字符结束,IDE将自动在其后绘制对应长度的单/双分隔线.可以在IDE设置选项中将此机制关闭.
> 
> ##### 3\. 嵌入行
> 
> > 文档或者方法程序行行首如果以一个独立的'**@** '字符开头(与后面的内容必须用空白字符隔开),则被称为**嵌入行**,该嵌入行在编译时将被直接发送到目的平台编译器,由用户自身保证该行的语法正确性.
> > 
> > 文档中可以使用"**@begin**"和"**@end**"关键字行括住一批程序行(注意 此方法不支持在类/方法中使用),这些程序行都将被视作嵌入行.
> > 
> > 嵌入行中可以使用以下替换符引用外部火山名称:
> > 
> > | | | |
> > |---|---|---|
> > |**格式**|**解释**|**样例**|
> > |@<成员名称>|引用所指定的成员/参数名称. <br> 注意: 为了避免重复替换产生错误,所有参数仅允许在嵌入行中引用一次,但是[需求类型](#)为"**数据类型**"的参数除外.|@<对象变量1>.test, @<对象变量1.成员1>|
> > |@n<成员名称>|引用所指定的成员名称,与前面格式文本不同的是: <br> > **1\.** 本格式文本仅加入最后一个成员名称. 譬如"@n<对象变量1.成员1>"仅会加入最后的"成员1"的名称,而不会加入前面的所有中间名称; <br> >  <br> > **2\.** 本格式文本引用成员时,不受静态成员访问格式限制. 譬如"@n<类1.成员1>",即使"成员1"不是常量/静态成员也可以被引用到; <br> >  <br> > **3.** 本格式文本引用成员时,不受访问权限的限制(譬如所访问成员是否公开等). <br> 由于去除了这些限制,开发者必须谨慎使用此替换符,必须能够保证该替换符获得的名称在任何场合下均能正常工作.|@n<对象变量1.成员1>|
> > |@dt<数据类型名称>|引用所指定的数据类型名称,包括: 基本数据类型/[模板数据类型](#)/类.   <br> 注意: <br> > **1.** 不支持数组数据类型; <br> >  <br> > **2\.** 类数据类型是否使用全名称自动根据当前实际位置需要,可以通过在前方明确加上包名来强制组成全名称; <br> >  <br> > **3.** 如果本替换符后跟随的不是对象成员访问字符(譬如句点),[别名类](#)将使用其所封装的本地类名,[常量类](#)将使用其所对应的基本数据类型.|@dt<整数>, @dt<模板类型1>, @dt<类1>, @dt<包1.类1>.静态变量1|
> > |@fdt<数据类型名称>|与"@dt"基本相同,除了类数据类型始终使用全名称.||
> > |@dtat\_vcls<数据类型名称, 附加文本>|如果所指定类型名称为火山类/本地火山类数据类型,则在当前位置加入所指定的附加文本. <br> 数据类型名称可以使用"@pdt"替换符引用指定参数数据的数据类型,附加文本中可以使用其它嵌入替换符,编译器会自动删除由于未满足条件加入附加文本而生成的空白嵌入行. 下同.||
> > |@dtat\_ncls<数据类型名称, 附加文本>|如果所指定类型名称为本地类/本地结构数据类型,则在当前位置加入所指定的附加文本.||
> > |@dtat\_cls<数据类型名称, 附加文本>|如果所指定类型名称为所有类数据类型(火山类/本地火山类/本地类/本地结构),则在当前位置加入所指定的附加文本.||
> > |@dtat\_not\_cls<数据类型名称, 附加文本>|如果所指定类型名称不为类数据类型(基本数据类型/本地整数基本类型/本地值类型/本地参考类型),则在当前位置加入所指定的附加文本.||
> > |@pvpt<参数名称>|引用为指定参数所提供实际调用立即数或常量文本值的对应字面文本(去除两侧双引号)||
> > |@pvpn<参数名称>|与"@pvpt"相同,只是要求所提供的字面文本为有效的英文名称文本.||
> > |@pdt<参数名称>|引用为所指定参数提供的实际调用值数据类型,包括: 基本数据类型/类.   <br> 注意: <br> > **1.** 所获取名称文本不包括数组数据类型的维定义部分; <br> >  <br> > **2.** 如果本替换符后跟随的不是对象成员访问字符(譬如句点),[别名类](#)将使用其所封装的本地类名,[常量类](#)将使用其所对应的基本数据类型; <br> >  <br> > **3\.** 类数据类型始终使用全名称; <br> >  <br> > **4\.** 方法名称参数值使用统一的"vmethod".||
> > |@pdt2<参数名称>|同"@pdt"唯一的不同是,以下类数据类型始终使用统一的名称: <br> > / / / <br> > /---/---/ <br> > /**火山类数据类型:**/"vcls"/ <br> > /**本地类**(由[别名类型](#)指定,下同)**:**/"ncls"/ <br> > /**本地结构:**/"nstruct"/ <br> > /**本地整数基本类型:**/"nnum"/ <br> > /**本地值类型:**/"nvalue"/ <br> > /**本地参考类型:**/"nref"/||
> > |@pad<参数名称>|所指定名称数组参数的数组维数文本,如果不为数组,则为"0".||
> > |@pdt\_ch<参数名称>|引用为所指定参数提供的实际调用值数据类型的标识字符,包括: 基本数据类型/类. <br> 数据类型的数组部分被忽略,常量类数据类型被转换到所对应的基本数据类型. <br> 数据类型与标识字符的对应表(区分大小写): <br> > / / / <br> > /---/---/ <br> > /**字节:**/b/ <br> > /**短整数:**/s/ <br> > /**字符:**/c/ <br> > /**整数:**/n/ <br> > /**变整数:**/p/ <br> > /**长整数:**/l/ <br> > /**小数:**/f/ <br> > /**逻辑值:**/B/ <br> > /**文本型:**/S/ <br> > /**火山类:**/C/ <br> > /**方法名:**/M/ <br> > /**本地类**(由[别名类型](#)指定,下同)**:**/w/ <br> > /**本地结构:**/W/ <br> > /**本地整数基本类型:**/N/ <br> > /**本地值类型:**/v/ <br> > /**本地参考类型:**/r/||
> > |@pdt\_list<参数名称>|引用从所指定参数开始到调用参数值表尾部所有参数值的实际数据类型列表(各数据类型之间使用逗号分隔),包括: 基本数据类型/类.   <br> 注意: <br> > **1.** 所获取名称文本不包括数组数据类型的维定义部分; <br> >  <br> > **2.** 如果本替换符后跟随的不是对象成员访问字符(譬如句点),[别名类](#)将使用其所封装的本地类名,[常量类](#)将使用其所对应的基本数据类型; <br> >  <br> > **3\.** 类数据类型始终使用全名称; <br> >  <br> > **4\.** 方法名称参数值使用统一的"func()"(本地目标语言为GO时)或"VOID\_FUNC".||
> > |@pkg<包名称>|引用所指定的包名称|@pkg<火山.用户.程序>|
> > |@an<约定名称>|引用所指定的全局/项目插件约定名称,其中全局约定名称由火山系统本身定义,插件约定名称由所使用的插件定义.|@an<onInitAndroidActivity>|
> > |@sn<特定名称>|引用所指定的特定名称,具体列表如下: <br> > **1.** "current\_class": 嵌入行当前调用位置所处类名(是否使用全名称自动根据当前实际位置需要,可以通过在前方明确加上包名来强制组成全名称). 所谓调用位置,为当调用该嵌入行所处嵌入式方法时,方法调用语句的所处位置; <br> >  <br> > **2.** "current\_package": 嵌入行当前调用位置所处包名; <br> >  <br> > **3\.** "current\_method": 嵌入行当前调用位置所处方法名; <br> >  <br> > **4.** "base\_class": 嵌入行当前调用位置所处类的基础类名(是否使用全名称自动根据当前实际位置需要,可以通过在前方明确加上包名来强制组成全名称); <br> >  <br> > **5.** "current\_class\_def": 嵌入行定义位置所处类名(是否使用全名称自动根据当前实际位置需要,可以通过在前方明确加上包名来强制组成全名称). 所谓定义位置,即定义该嵌入行的具体位置; <br> >  <br> > **6.** "current\_package\_def": 嵌入行定义位置所处包名; <br> >  <br> > **7.** "base\_class\_def": 嵌入行定义位置所处类的基础类名(是否使用全名称自动根据当前实际位置需要,可以通过在前方明确加上包名来强制组成全名称); <br> >  <br> > **8\.** "startup\_method": 程序启动方法名(启动方法必须位于启动类中) <br> >  <br> > **9.** "startup\_class": 程序启动类名(是否使用全名称自动根据当前实际位置需要,可以通过在前方明确加上包名来强制组成全名称); <br> >  <br> > **10.** "startup\_package": 程序启动类所处包的包名; <br> >  <br> > **11.** "this": 只能在非静态嵌入式方法中的嵌入行里使用,将被替换为调用该嵌入式方法时提供的调用对象; <br> >  <br> > **12\.** "quot": 双引号字符; <br> >  <br> > **13.** "apos": 单引号字符; <br> >  <br> > **14\.** "lt": 左尖括号字符; <br> >  <br> > **15.** "gt": 右尖括号字符; <br> >  <br> > **16.** "nbsp": 空格字符; <br> >  <br> > **17\.** "pm\_types": 为调用该嵌入式方法时所提供的全部参数的实际调用值数据类型的标识字符串.字符串两侧使用双引号括住,数据类型的数组部分被忽略,常量类数据类型被转换到所对应的基本数据类型,每个参数调用值数据类型对应一个标识字符(区分大小写),具体数据类型与标识字符的对应表见"[@pdt\_ch](#)"处: <br> >  <br> > > 如果参数调用值数据类型为类,可以通过其运行时类型信息来进行进一步判定其具体是什么类. <br> >  <br> > **18.** "rand\_name0" 到 "rand\_name9": 随机生成的程序内唯一性名称. <br> >  <br> > > 注意在同一条嵌入语句行或同一个嵌入式方法体中所有的嵌入语句行内,同一随机名称("rand\_name0" 到 "rand\_name9")将为同一名称文本. <br> > >  <br> > > 譬如假设在一个嵌入式方法的方法体内存在以下语句内容: <br> > >  <br> > > > for (int @sn<rand\_name5> = 0; @sn<rand\_name5> < 3; @sn<rand\_name5>++) <br> > >  <br> > > 其中"@sn<rand\_name5>"所生成的随机名称在整个程序内为唯一性名称,但是在该嵌入式方法体内这三个位置处将为同一个名称文本. <br> >  <br> > **19\.** "current\_statment": 当前语句的位置字符串,格式: "<所处源文件名>, 所处源文件行号, 所处包名.所处类名, 所处方法名". <br> >  <br> > **20.** "current\_source\_file": 当前语句所处源文件名 <br> >  <br> > **21.** "current\_source\_line": 当前语句在所处源文件中的行号位置 <br> >  <br> > **22.** "current\_source\_package": 当前语句所处包名 <br> >  <br> > **23.** "current\_source\_class": 当前语句所处类名 <br> >  <br> > **24.** "current\_source\_method": 当前语句所处方法名|@sn<current\_class> <br> @sn<current\_package> <br> @sn<base\_class> <br> @sn<startup\_method> <br> @sn<startup\_class> <br> @sn<startup\_package> <br> @sn<this> <br> @sn<quot> <br> @sn<apos> <br> @sn<pm\_types> <br> @sn<rand\_name>|
> > |@def\_macro|定义可以在嵌入行中使用的宏,目前不支持在方法中定义. 语法格式为: <br> > **1\.** 不携带参数表方式: <br> >  <br> > > @def\_macro 宏名称 宏内容 <br> > >  <br> > > 在使用该宏时将直接使用宏内容对该宏进行替换. <br> > >  <br> > > 如: @def\_macro TEST wutao <br> > >  <br> > > 使用该宏时,如 @m<TEST>,该宏替换后的实际内容将为 wutao . <br> >  <br> > **2\.** 携带参数表方式: <br> >  <br> > > @def\_macro 宏名称(宏参数名称, ...)  宏内容 <br> > >  <br> > > **注意事项:** <br> > >  <br> > > **A.** 参数表的左括号必须紧跟在宏名称后面,中间不能存在空白字符,不然就会被认为是宏内容的一部分; <br> > >  <br> > > > 如: @def\_macro TEST(param1) param1 <br> > > >  <br> > > > 该宏的名称为TEST,具有一个名为param1的宏参数,宏内容是直接使用该参数. <br> > > >  <br> > > > 如果左括号与TEST之间存在空白字符的话,如: @def\_macro TEST  (param1) param1 <br> > > >  <br> > > > 那么该宏就是一个名为TEST,没有参数,宏内容为"(param1) param1". <br> > >  <br> > > **B.** 参数表中可以包括一个或多个宏参数名称,多个参数名称之间使用逗号进行分隔; <br> > >  <br> > > > 如: @def\_macro MY\_ADD(param1, param2) param1 + param2 <br> > >  <br> > > **C.** 宏内容中可以使用参数表内定义的宏参数名称,在使用该宏时将使用对应的实际参数内容进行替换; <br> > >  <br> > > **D.** 在宏内容中所使用的宏参数名称,如果其前方为1个'#'字符,该"#宏参数名"在进行宏替换时将被替换为字符串格式,即自动在两侧加上双引号; <br> > >  <br> > > > 如: @def\_macro TEST(param1) #param1 <br> > > >  <br> > > > 使用该宏时,如 @m<TEST> (abc) ,该宏替换后的实际内容将为 "abc" ,注意abc两侧双引号也是替换后内容的一部分. <br> > >  <br> > > **E.** 在宏内容中所使用的宏参数名称,如果其前/后方为2个'#'字符,该宏参数名在进行宏替换时将自动与其前/后方内容连接起来. <br> > >  <br> > > > 如: @def\_macro TEST(param1,param2) wutao\_##param1##param2##\_var <br> > > >  <br> > > > 使用该宏时,如 @m<TEST> (abc,bcd) ,该宏替换后的实际内容将为 wutao\_abcbcd\_var ,前后文本将连接在一起. <br> > >  <br> > > **F.** 如果使用宏时所提供的实际参数数目超出当前所定义宏参数数目,则所有多余参数内容将被统一视为最后一个宏参数的替换内容. <br> > >  <br> > > > 如: @def\_macro TEST(param1) param1 <br> > > >  <br> > > > 使用该宏时如果提供了多余的参数,如 @m<TEST> (abc, bcd) ,则最终得到的替换结果就是 abc, bcd ,而不会报错. <br> > > >  <br> > > > 此特性是为了支持将目标语言的复杂代码文本指定为宏的最后一个参数的内容,如: <br> > > >  <br> > > > @m<TEST> (myObject.myMethod (1, 2, 3)) ,最终得到的替换结果就是 myObject.myMethod (1, 2, 3) . <br> >  <br> > **3\.** 多行宏内容: <br> >  <br> > > 如果宏内容包括多行,可以在当前行的尾部使用'\\'字符标记其紧接着的下一嵌入行也属于本宏的内容.如果当前行的尾部为双引号,而且下一行的首部也为双引号,则这两个字符串将合并到一起. <br> > >  <br> > > 如: <br> > >  <br> > > > @def\_macro TEST wutao  \\   <br> > > > volcano  \\   <br> > > > dev <br> > >  <br> > > 使用该宏时所最后得到的替换结果为: <br> > >  <br> > > > wutao   <br> > > > volcano   <br> > > > dev <br> > >  <br> > > 再如: <br> > >  <br> > > > @def\_macro TEST "wutao "  \\   <br> > > > "volcano" <br> > >  <br> > > 使用该宏时所最后得到的替换结果为: <br> > >  <br> > > > "wutao volcano" <br> >  <br> > **4\.** 宏内容中可以使用本表中列出的除开宏定义本身以外的所有其它替换符,包括使用其它宏.|
> > |@m<宏名称> (参数表)|使用所指定名称的宏,可以在后方跟随一个参数表(注意此处不再限制左括号与其前方不能留空白字符),参数表中的所有参数用作替换对应的宏参数. <br> 注意: <br> > **1\.** 如果所欲使用的宏在类中定义,并且当前使用位置不位于该类中,则必须在宏名称前加上类名前缀; <br> >  <br> > **2\.** 如果所使用宏未指定类名前缀,且其当前使用位置所处类及程序全局中均定义有该名称的宏,则将使用类中定义的宏; <br> >  <br> > **3\.** 可以跨越多行提供宏参数表. 如: <br> >  <br> > > @m<TEST> ("wutao",   <br> > >         "volcano") <br> 使用格式: <br> > **1\.** 不携带参数表方式: <br> >  <br> > > 如: @m<TEST> <br> >  <br> > **2\.** 携带参数表方式: <br> >  <br> > > 如: @m<TEST> ("wutao", "volcano") <br> > >  <br> > > 注意[如前所述](#),如果所提供的实际参数数目大于所使用宏中定义的宏参数数目,则所有多余部分将被视为宏的最后一个参数的内容.|
> 
> > 替换符中可以提供一个使用逗号分隔的选项参数字符集合,其格式为: @xx<替换名称, 选项参数字符集文本>
> > 
> > 目前有效的选项字符有:
> > 
> > > | | |
> > > |---|---|
> > > |选项字符|说明|
> > > |n|指定使用相关成员的纯粹名称. <br> **1\.** 当本地语言为GO时,火山编译器会将所有类对应的数据类型编译为GO的参考格式,即"类1"所对应的GO数据类型为星号字符加"类1"的实际输出名,此即为类似"@dt<类1>"替换符的替换文本. 当在某种情况下不需要这个星号时,就可以通过"@dt<类1, n>"格式来去掉此星号; <br> **2\.** 当本地语言为C++时,如果数据类型尾部以星号('\*')字符结束,则将其去除; 首部以"P" / "P\_" / "LP" / "LP\_"文本开头,亦将其去除. 前者优先.|
> > > |e|指定当未找到所指定名称的成员时,是否不报告编译错误(此时其所处嵌入行将被整体全部删除). <br> 如,以下嵌入行: <br>     @n<启动类.\_调试启动方法, e> (); <br> 当"启动类"存在"\_调试启动方法"时,将正常输出对应嵌入行内容,当不存在时,将删除整个嵌入行. <br> 本选项字符可以结合 "@dt", "@fdt", "@pkg", "@an", "@n"及直接的"@<成员名称>"替换符使用.|
> > > |b|指定当找到所指定名称的成员时,将其替换为一个逻辑值真文本,未找到则替换为一个逻辑值假文本. 如以下嵌入行: <br> #if @n<启动类.方法1, b> <br> 当"启动类"存在"方法1"时,所输出嵌入行内容为"#if TRUE",当不存在时,所输出内容为"#if FALSE". <br> 本选项字符可以结合 "@dt", "@fdt", "@pkg", "@an", "@n"及直接的"@<成员名称>"替换符使用.|
> 
> ##### 4\. 类定义
> 
> > 类用作定义一个可以具有子成员的数据类型.
> > 
> > 类可以单根继承一个基础类,引用类名时可以直接使用类名称,或者使用"包名.类名"进行全名引用.
> > 
> > 注意: 名称为"**启动类**"的类被用作特定定义用户程序的启动类
> > 
> > 基本属性表:
> > 
> > | | |
> > |---|---|
> > |**名称**|**解释**|
> > |基础类|指定本类的基础类名称,可以是单名称/全名称,也可以是空文本(表示无基础类). <br> 如果定义了非空基础类,当前类将自动继承所有来自该基础类的内容,如果该基础类还有基础类,将一并继承过来,此时本类称为这些类的"**继承类**". <br> 继承类访问其直接/间接基础类中的成员不需要其为公开状态. <br> 如果本类为[模板基础类](#),则可以使用[模板数据类型](#)来动态提供其基础类.|
> > |公开|指定本类是否对外公开. 公开类可以在所处包外部被访问,而非公开类只能在所处包内部被访问.|
> 
> ##### 5\. 类成员常量或局部常量定义
> 
> > 常量用作定义一个不允许在程序中进行修改的恒定值.
> > 
> > 类的成员常量在其外部应该通过"**类名.常量名**"的方式来引用.
> > 
> > 基本属性表:
> > 
> > | | |
> > |---|---|
> > |**名称**|**解释**|
> > |类型|提供常量的数据类型,只能是基本数据类型或[常量类](#).|
> > |公开|指定本常量是否公开.公开常量可以在所处类外部被访问,而非公开常量只能在本类或者其继承类中访问. <br> 局部常量没有本属性.|
> > |初始值|提供常量的初始值立即数,必须对应常量的数据类型. 注意: <br> > **1\.** 在设置常量初始值时,只能提供[立即数](#),不能提供其它常量; <br> >  <br> > **2\.** 可以使用'**@**'字符引导的文本来指定常量的本地初始化值文本(用户自行保证其有效性,火山编译器不会检查). 如: <br> >  <br> > > ![](https://doc.voldp.com/images/b51.png)|
> 
> ##### 6\. 类成员变量或局部变量定义
> 
> > 变量的内容允许在程序中被动态修改.
> > 
> > 基本属性表:
> > 
> > | | |
> > |---|---|
> > |**名称**|**解释**|
> > |类型|提供变量的数据类型|
> > |静态|指定是否为静态变量.静态变量在所处类载入后即保持始终存在. <br> 由于静态变量初始化时不存在所处类实例,静态成员变量不支持自动挂接其事件到其所处类,在需要时必须通过"[挂接事件](#)"命令手动挂接. <br> 类的静态成员变量在外部应该通过"**类名.变量名**"的方式来引用. <br> 非静态的类成员变量,如果其数据类型为类且其中定义有事件,将被自动挂接到当前类实例对象.|
> > |参考|指定是否为参考变量. <br> **注意:** <br> > 变量的参考属性如果为假,将自动创建一个对应数据类型的实例对象; <br> >  <br> > 如果为真,则仅为用作指向另外一个已有实例对象的引用,本身并不创建实例对象.|
> > |公开|指定本变量是否公开.公开变量可以在所处类外部被访问,而非公开变量只能在本类或者其继承类中访问. <br> 局部变量没有本属性.|
> > |初始值|提供变量的初始值,必须对应变量的数据类型. <br> 在设置变量初始值时,可以提供[立即数](#),也可以提供[常量](#). <br> 设置参考变量的初始值时,可以提供[空对象](#). <br> 如果未提供初始值,数值型变量的初始值为0,逻辑型变量的初始值为假,文本型变量的初始值为空文本,参考变量("参考"属性为真的变量)的初始值为[空对象](#).|
> 
> ##### 7\. 类方法定义
> 
> > 定义类的方法
> > 
> > 名称为"**类\_初始化**"的方法为类的初始化方法(在类对象被创建时自动调用),该方法不携带任何参数并且不返回值,对是否公开没有要求.
> > 
> > 名称为"**类\_清理**"的方法为类的清理方法(在类对象被销毁时自动调用),该方法不携带任何参数并且不返回值,对是否公开没有要求. **注意**:在某些目标语言平台(如Java)上,类清理方法不会被支持.
> > 
> > 基本属性表:
> > 
> > | | |
> > |---|---|
> > |**名称**|**解释**|
> > |返回值类型|提供方法执行完毕后所返回数据的数据类型|
> > |静态|指定是否为静态方法. 注意: <br> > **1\.** 类的静态方法需要通过"类名.方法名"的方式来引用; <br> >  <br> > **2\.** 在静态方法内部，只能访问其所处类或者其所处类的基础类中的成员常量或者静态成员变量; <br> >  <br> > **3\.** 如果静态方法所定义第一个参数的数据类型为方法所处类本身而且没有指定参数[匹配](#)和[需求类型](#),那么可以基于该类对象以动态格式来调用该静态方法,编译器将自动进行转换. <br> >  <br> > > **如:** 假设"类1"中定义了"方法1",而"方法1"的第一个参数数据类型为"类1",类似这样的静态调用格式"类1.方法1 (类1对象, ...)"可以以"类1对象.方法1 (...)"的动态调用格式进行书写.|
> > |类别|指定方法的具体类别,可以为以下几种之一: <br> > **1\. 通常:** 表明本方法为通常方法 <br> >  <br> > **2\. 属性读:** 表明本方法为属性读取方法. 该属性可以在程序语句中被读取. <br> >  <br> > > 如果属性读方法为静态方法,所要求的定义格式: <br> > >  <br> > > > **A**. 必须定义且只能定义一个参数,该参数的数据类型必须为属性读方法所处类本身; <br> > > >  <br> > > > **B**. 必须定义有返回值,该返回值的数据类型不能为数组,该数据类型即为本属性被读取时的数据类型. <br> > >  <br> > > 如果属性读方法不为静态方法,所要求的定义格式: <br> > >  <br> > > > **A**. 不能定义参数; <br> > > >  <br> > > > **B**. 必须定义有返回值,该返回值的数据类型不能为数组,该数据类型即为本属性被读取时的数据类型. <br> > >  <br> > > 注意: <br> > >  <br> > > > **A**. 在程序中,必须以与变量相同的引用方式来访问属性读方法. 如: "类对象1.属性1"; <br> > > >  <br> > > > **B**. 如果存在同名属性写方法,则两者的数据类型必须一致; <br> > > >  <br> > > > **C**. 在[全局类](#)中不能定义属性读方法. <br> >  <br> > **3\. 属性写:** 表明本方法为属性写入方法. 该属性除了可以在程序语句中被赋值,还可以在该类对象变量的扩展属性表的"**属性**"列中被赋予初始值. <br> > > 如果属性写方法为静态方法,所要求的定义格式: <br> > >  <br> > > > **A**. 必须未定义返回值; <br> > > >  <br> > > > **B**. 必须定义且只能定义两个参数,第一个参数的数据类型必须为属性写方法所处类本身,第二个参数的数据类型不能为数组,该数据类型即为本属性被写入时 所需要的数据类型. <br> > >  <br> > > 如果属性写方法不为静态方法,所要求的定义格式: <br> > >  <br> > > > **A**. 必须未定义返回值; <br> > > >  <br> > > > **B**. 必须定义且只能定义一个参数,该参数的数据类型不能为数组,该数据类型即为本属性被写入时所需要的数据类型. <br> > >  <br> > > 注意: <br> > >  <br> > > > **A**. 在程序中,必须以与变量相同的引用方式来访问属性写方法. 如: "类对象1.属性1 = 1"; <br> > > >  <br> > > > **B**. 如果存在同名属性读方法,则两者的数据类型必须一致; <br> > > >  <br> > > > **C**. 在[全局类](#)中不能定义属性写方法. <br> >  <br> > **4\. 定义事件:** 定义本类对象将会发送事件的名称及格式,此种方法必须满足以下格式要求: <br> >  <br> > > **A.** 方法体必须为空; <br> > >  <br> > > **B.** 返回值数据类型必须为整数(安卓和服务器子平台无此限制); <br> > >  <br> > > **C.** 不能为静态方法. <br> >  <br> > **5\. 接收事件:** 定义本类对象将会接收本类中成员变量对象所发送的事件,此种方法且必须满足以下要求: <br> >  <br> > > **A.** 返回值数据类型必须为整数(安卓和服务器子平台无此限制); <br> > >  <br> > > **B.** 不能为静态方法; <br> > >  <br> > > **C.** 方法名称格式必须为: 事件对象类名 + "\_" + 欲接收事件名; <br> > >  <br> > > **D.** 方法的第1个参数的数据类型必须为欲接收其事件的事件对象类名; <br> > >  <br> > > **E.** 方法的第2个参数的数据类型必须为整数,用作接收"[挂接事件](#)"关键字调用所提供的"标记值"参数值(非该方式挂接事件则此参数值固定为0); <br> > >  <br> > > **F.** 方法其余参数的数目及数据类型必须与欲接收事件的定义方法一致.|
> > |公开|指定本方法是否公开.公开方法可以在所处类外部被访问,而非公开方法只能在本类或者其继承类中访问.|
> > |参数表|定义本方法的所有参数|
> 
> ##### 8\. 程序语句
> 
> > 提供具体的方法实现语句代码.
> > 
> > **A.** 语法格式描述文本的规则:
> > 
> > > 语法格式描述文本为由以下运算符组合的一个或多个语法项构成,这些运算符的优先级按顺序从小到大递增:
> > > 
> > > +   **|** : 备选项(在多个项目中选择其中任意一个).
> > > +   **()** : 分组项(提供一组备选项).
> > > +   **\[\]** : 可选存在项(可以存在也可以不存在).
> > > +   **{}** : 重复存在项(可以重复存在0到n次).
> > > 
> > > 语法项分为字面文本项(用双引号括住)和语法替换项两种.
> > 
> > **B.** 语句行的语法格式描述文本:
> > 
> > > +   **语句**: 赋值表达式 | 调用表达式
> > > +   **表达式**: 一元表达式 | 表达式 二元操作符 表达式
> > > +   **一元表达式**: 基本表达式 | 一元操作符 一元表达式
> > > +   **基本表达式**: 操作数 | 类型强转表达式 | 对象成员访问表达式 | 数组成员访问表达式 | 调用表达式
> > > +   **操作数**: 立即数 | 名称 | "(" 表达式 ")"
> > > +   **赋值表达式**: (局部变量名称 | 所处方法参数名称 | 对象成员访问表达式 | 数组成员访问表达式) "=" 表达式
> > > +   **类型强转表达式**: "(" 类型名称 ")" 一元表达式
> > > +   **对象成员访问表达式**: 类成员名称 | 类访问名称 "." 类成员名称 | 基本表达式 "." 类成员名称 | "父对象" "." 父类成员名称 | 本对象
> > > +   **数组成员访问表达式**: 基本表达式 "\[" 表达式 "\]" { "\[" 表达式 "\]" }
> > > +   **调用表达式**: 对象成员访问表达式 调用参数表 | 命令关键字名称 调用参数表
> > > +   **一元操作符**: "-"
> > > +   **二元操作符**: "&&" | "||" | "==" | "!=" | "<" | "<=" | ">" | ">=" | "属于" | "\*" | "/" | "%" | "+" | "-"
> > > +   **调用参数表**: "(" \[ 表达式 { "," 表达式 } \] ")"
> > > +   **类型名称**: 基本类型名称 | 类访问名称
> > > +   **基本类型名称**: 字节 | 短整数 | 字符 | 整数 | 变整数 | 长整数 | 单精度小数 | 小数 | 逻辑型 | 文本型
> > > +   **类访问名称**: 类的定义名称 | 类所处包名 "." 类的定义名称
> 
> ##### 9\. 编译相关
> 
> > **1\. 按需编译:**
> > 
> > > 火山编译器实行的是按需编译模式,也就是说,凡是不可能被执行到的代码,一概不进行编译. 具体为:
> > > 
> > > > 从程序的启动位置开始,所有未在程序执行流程中的代码都将不会被编译.
> > 
> > **2\. 命令行编译:**
> > 
> > > 火山系统(非免费版)支持以命令行格式进行编译,具体命令行格式为:
> > > 
> > > > voldev\_xxx.exe @compile 欲编译火山项目解决方案文件名 \[/r\] \[/c\] \[/d\]
> > > > 
> > > > 参数说明:
> > > > 
> > > > > /r: 是否强制重新编译
> > > > > 
> > > > > /c: 是否仅生成目标代码而不进行本地编译
> > > > > 
> > > > > /d: 是否生成调试版(不设置本选项则生成发布版)
> > > > 
> > > > 编译成功进程返回值为0,否则返回-1.  
> > > >  
> 
> **10\. 部件程序**
> 
> > 在某些情况下,可能希望程序的功能实现源代码不公开但是又不影响最终编译,此时可以使用部件程序.
> > 
> > 部件程序与普通程序的区别在于,部件程序可以将普通程序分为两个部分,一个是其公开接口部分,如被公开的类/方法等(可以通过"[@输出到部件](#)"属性调节).,另一个是其功能实现部分,公开接口部分在系统程序编辑器中可以被阅读(不能修改),仅在编辑项目时使用,功能实现部分则在编辑器中被隐藏不可见,仅在编译项目时使用,两者互不影响.
> > 
> > 当根据普通程序生成其部件程序时,其中如存在名为"启动类"的类,将被自动忽略跳过(可以通过"[@输出到部件](#)"属性调节).
> > 
> > 除了以上区别之外,部件程序与普通程序没有任何差异,所有可以使用普通程序的场合均可使用部件程序.
> 
> **11\. 火山".wsv"文本格式源程序**
> 
> > 火山平台现在支持将源程序以Unicode文本格式保存(后缀为".wsv"),该文本源程序与通常的火山源程序(".v")相比有以下不同:
> > 
> > > **1.** 保存格式为Unicode文本形式,可以直接使用文本编辑器查看;
> > > 
> > > **2.** 载入及编译速度比".v"格式较慢,且无法保存书签/调试断点之类信息.
> > 
> > 文本程序数据分为**完整程序数据**和**剪切程序数据**两种,前者用作保存一个完整的火山程序数据,后者用作保存复制到剪贴板中的火山程序数据片段.
> > 
> > 火山文本格式源程序语法规则见下.
> > 
> > 规则描述格式:
> > 
> > > **A.** 规则描述中的名称如果以 **xxx/xxx** 格式提供,则分别为其中文和英文名称;
> > > 
> > > **B.** 规则描述中,中括号括住的名称表示该部分可以被省略.
> > 
> > **1\.** 首非空行必须为文档格式和版本定义行(无论是完整程序数据还是剪切程序数据):
> > 
> > > <火山程序/volprg 类型/type = *类型名称* 版本/version = *版本号* />
> > > 
> > > 类型名称: 提供当前火山程序文档的格式类型文本,目前支持的有: "通常" / "normal"
> > > 
> > > 版本号: 目前最新版本号为 1
> > 
> > **2\.** 各种类型成员的定义格式:
> > 
> > > 成员名称格式要求: 成员名称如果不为有效的单/全名称文本,就必须使用以双引号括住的转义字符串格式.
> > > 
> > > 所有以花括号括住的代码块如果其中内容为空,则整个花括号代码块可以全部被省略.
> > 
> > > | | | | |
> > > |---|---|---|---|
> > > |**类型**|**语法格式**|所支持系统属性|注释|
> > > |包|包/package *包名称* \[属性表\]|注释 <br> 折叠2|必须为第一个成员定义而且只能存在一个.|
> > > |类|类/class *类名称* \[属性表\] <br> { <br>     类定义体 <br> }|公开 <br> 基础类 <br> 注释 <br> 折叠 <br> 折叠2|必须位于文档顶层|
> > > |方法|方法/method *方法名称* \[属性表\] <br> \[参数表\] <br> ... <br> { <br>     子语句体 <br> }|公开 <br> 静态 <br> 定义事件 <br> 接收事件 <br> 属性读 <br> 属性写 <br> 类型 <br> 注释 <br> 返回值注释 <br> 折叠 <br> 折叠2|1\. 参数表为所有参数的定义行集合,如果存在必须顺序排列在方法定义行的下面. <br> 2\. 必须位于类定义体中,剪切程序数据中可以位于文档顶层.|
> > > |参数|参数/param *参数名称* \[属性表\]|类型 <br> 注释 <br> 折叠(仅限首参数) <br> 折叠2|必须跟随在方法定义行后面,剪切程序数据中可以位于文档顶层.|
> > > |常量|常量/const *常量名称* \[属性表\]|公开(仅限类成员常量) <br> 类型 <br> 值 <br> 注释 <br> 折叠(仅限多个连续常量中的首常量) <br> 折叠2|必须位于类定义体(成员常量)或方法子语句体(局部常量)中,剪切程序数据中可以位于文档顶层.|
> > > |变量|变量/var *变量名称* \[属性表\]|公开(仅限类成员常量) <br> 静态 <br> 参考 <br> 类型 <br> 值 <br> 注释 <br> 折叠(仅限多个连续变量中的首变量) <br> 折叠2|必须位于类定义体(成员变量)或方法子语句体(局部变量)中,剪切程序数据中可以位于文档顶层.|
> > > |文档或类注释/嵌入行|\# \[属性表\] 注释/嵌入行内容||必须位于文档顶层或类定义体中. <br> **注意:** <br> > 如果注释/嵌入行内容以 '<' 字符开头,则无论该行是否具有属性,都必须在内容前方添加一个空属性表. 如: \# <abc 就必须使用 \# <> <abc 表达.|
> > > |语句行|\[属性表\] 语句行内容 <br> { <br>     子语句体 <br> }|折叠|必须位于方法或另一语句的子语句体中,剪切程序数据中可以位于文档顶层. <br> **注意**,在以下几种情况下,无论该行是否具有属性,都必须在内容前方添加一个空属性表: <br> > 1\. 语句行内容以 '<' 字符开头; <br> >  <br> > 2\. 语句行内容以以下单词(以空白字符和后方内容隔开)开头: 包, package, 类, class, 方法, method, 参数, param, 常量, const, 变量, var ; <br> >  <br> > 3\. 语句行内容为单个的 '{' 或 '}' 字符. <br> >  <br> > 如: const int i 语句行必须以 <> const int i 表达, <123 语句行必须以 <> <123 表达.|
> > 
> > **3\.** 属性表的定义格式:
> > 
> > > <*属性名称* \[ = *属性值*\] ......>
> > > 
> > > 属性表内容以一个或多个以空白字符分隔的名称和值对组成,其中可以使用换行符在多行中进行描述.
> > > 
> > > 属性名称格式要求:
> > > 
> > > > 属性名称如果不为有效的单/全名称文本(可以以'@'字符引导),或者为与已有系统属性(见下面系统属性表)的中/英文名称相同的非系统属性,必须使用以双引号括住的转义字符串格式.
> > > 
> > > 属性值格式要求:
> > > 
> > > > **A.** 如果当前属性为除开"**值**"以外的系统属性,则可以为以下几种格式:
> > > > 
> > > > > 1\. 单/全名称文本;
> > > > > 
> > > > > 2\. 以下数据类型的有效值:
> > > > > 
> > > > > > 逻辑值. 如: 真 / 假
> > > > > > 
> > > > > > 数值. 如: 123, 1.23, 0x123, -123, 1.23e3
> > > > > 
> > > > > 3\. 以双引号括住的转义字符串. 当属性值无法以前面几项描述时,必须以此格式描述,系统将取用该字符串转义后的字面文本作为属性值. 譬如, 属性值 123a ,就必须以 "123a" 进行描述;
> > > > > 
> > > > > 4\. 如果没有提供属性值,则该属性的值默认为逻辑值真.
> > > > 
> > > > **B.** 如果当前属性为"**值**"系统属性或非系统属性,则可以为以下几种格式:
> > > > 
> > > > > 1\. 单/全名称文本;
> > > > > 
> > > > > 2\. 以下数据类型的有效值:
> > > > > 
> > > > > > 数组. 如: { 1, 2, 3 }
> > > > > > 
> > > > > > 逻辑值. 如: 真 / 假
> > > > > > 
> > > > > > 文本. 如: "abc"
> > > > > > 
> > > > > > 字符. 如: 'a'
> > > > > > 
> > > > > > 数值. 如: 123, 1.23, 0x123, -123, 1.23e3
> > > > > 
> > > > > 3\. 以'@'字符开头的单/全名称文本(火山程序中用作引用本地名称值);
> > > > > 
> > > > > 4\. 以'@'字符开头的以双引号括住的转义字符串. 当属性值无法以前面几项描述时,必须以此格式描述,系统将取用该字符串转义后的字面文本作为属性值. 譬如, 属性值 123a ,就必须以 @"123a" 进行描述.
> > > > > 
> > > > > 5\. 如果没有提供属性值,则该属性的值默认为无.
> > 
> > 4\. 系统属性表:
> > 
> > > | | | | |
> > > |---|---|---|---|
> > > |名称|数据类型|可应用到成员|注释|
> > > |类型 / type|文本型|常量, 变量, 参数, 方法|提供成员的数据类型|
> > > |公开 / public|逻辑型|类, 方法, 成员常量, 成员变量|指定成员是否被公开|
> > > |静态 / static|逻辑型|方法, 变量|指定成员是否具有"静态"属性|
> > > |参考 / ref|逻辑型|变量|指定成员是否具有"参考"属性|
> > > |定义事件 / event|逻辑型|方法|指定方法的类别是否为"定义事件"|
> > > |接收事件 / receiver|逻辑型|方法|指定方法的类别是否为"接收事件"|
> > > |属性读 / getter|逻辑型|方法|指定方法的类别是否为"属性读"|
> > > |属性写 / setter|逻辑型|方法|指定方法的类别是否为"属性写"|
> > > |基础类 / base\_class|文本型|类|提供类的基础类名称|
> > > |值 / value|文本型|常量, 变量|提供常量或变量的初始值|
> > > |注释 / explain|文本型|包, 类, 常量, 变量, 参数, 方法|提供成员的注释. 如果属性表内具有多个本属性,将会分行组合在一起.|
> > > |返回值注释 / res\_explain|文本型|方法|提供方法的返回值注释. 如果属性表内具有多个本属性,将会分行组合在一起.|
> > > |折叠 / collapsed|逻辑型|类, 方法, 语句(有子语句体), 常量/变量/参数表的首成员|指定类或方法体,语句的子语句体,常量/变量/参数表是否被折叠.|
> > > |折叠2 / collapsed2|逻辑型|包, 类, 常量, 变量, 参数, 方法. <br> 以上成员要求存在多行属性表或多行注释.|指定多行属性表或多行注释是否被折叠|
> > > |编辑时信息 / edit\_info|文本型|包, 类, 常量, 变量, 参数, 方法.|十六进制值列表,用作保存成员在编辑时的相关信息,如被调节列宽度等.|
> > > |隐藏值属性 / hidden\_value\_attr|文本型|包, 类, 常量, 变量, 参数, 方法.|整数值列表,用作保存所有值被隐藏的用户属性索引位置|
> > 
> > **5\. 样例:**
> > 
> > > **文本程序内容:**
> > > 
> > > > <火山程序 类型 = "通常" 版本 = 1 />  
> > > >   
> > > > 包 火山.程序 <@视窗.外部文件 = "c:\\\\abc.cpp" "测试属性>" = @"123a">  
> > > >   
> > > > \# 注释行1  
> > > > \# @ 嵌入行  
> > > > \# <> <abc  
> > > >   
> > > > 类 测试类1 <"公开" 公开 基础类 = 我的基础类 "位 置" = 1 "#属性1" = 2  
> > > >         注释 = "注释行1"  
> > > >         注释 = "注释行2\\n注释行3">  
> > > > {  
> > > >     变量 变量1  
> > > >     变量 变量2 <值 = { "a", { "b", "c" }, "d" } 属性1 = ' ' 属性2 = "abc\\t" 类型 = "文本型 \[\]">  
> > > >     变量 变量3 <值 = ' ' 类型 = 字符>  
> > > >   
> > > >     方法 "// 方法1"  
> > > >   
> > > >     方法 方法2 <折叠2 静态 方法属性 = "abc" 类型 = 整数  
> > > >             返回值注释 = "注释1"  
> > > >             返回值注释 = "注释2\\n注释3">  
> > > >     参数 参数1 <类型 = "整数 \[\]" 参数属性1 = 1 注释 = "这是我的参数">  
> > > >     参数 参数2 <类型 = 字节集 参数属性2 = 2>  
> > > >     {  
> > > >         @ 嵌入语句行  
> > > >         参数1.信息框 ("abc") // 注释信息  
> > > >   
> > > >         变量 局部变量1 <参考 注释="这是我的\\n变量">  
> > > >         常量 局部常量 <类型 = 文本型 值 = @"123 程序">  
> > > >   
> > > >         <> 包 ...  
> > > >         <> 类 ...  
> > > >         <> 变量 ...  
> > > >         <> 常量 ...  
> > > >         <> 参数 ...  
> > > >         <> 方法 ...  
> > > >         <> {  
> > > >         我的函数 ()  
> > > >         <> }  
> > > >         <> <...  
> > > >         <> #...  
> > > >   
> > > >         如果 (局部变量1 == 1)  
> > > >         {  
> > > >             我的函数 ()  
> > > >         }  
> > > >         <折叠> 循环 ()  
> > > >         {  
> > > >             参数1.信息框 ("abc") // 注释信息  
> > > >         }  
> > > >     }  
> > > > }
> > 
> > **对应的火山程序内容:**
> > 
> > > ![](https://doc.voldp.com/images/txtprg.png)  
> > >  

#### 四. 火山平台关键字表:

##### 1\. 基本数据类型关键字:

| | | |
|---|---|---|
|**名称**|**输入字1**|**解释**|
|字节|sbyte|字节(有符号)基本数据类型,有效值范围从-128到127,占用1个字节空间. <br> **特例:** 在服务器子平台中,本数据类型无符号,即有效值范围从0到255.|
|短整数|short|短整数基本数据类型,有效值范围从-32768到32767,占用2个字节空间.|
|字符|wchar|宽字符基本数据类型,有效值范围从0到65535,占用2个字节空间. <br> **特例:** 在服务器子平台中,本数据类型等同于32位整数,占用4个字节空间,有效值范围从-2147483648到2147483647.|
|整数|int|整数基本数据类型,有效值范围从-2147483648到2147483647,占用4个字节空间. <br> **特例:** 在编译64位服务器子平台程序时,有效值范围等同于长整数,占用8个字节空间. 在服务器子平台中如欲限定使用32位整数请使用"字符"数据类型等同替代.|
|变整数|vint|变整数基本数据类型,在编译64位视窗子平台程序时等同于长整数类型,编译32位视窗子平台程序时等同于整数类型,在其它情况下均等同于整数类型. <br> 由于变整数的数据尺寸等于当前目的cpu的位数,因此常用作表达c/c++目的程序里面的指针值.|
|长整数|long|长整数基本数据类型,有效值范围从-9223372036854774808到9223372036854774807,占用8个字节空间.|
|单精度小数|float|单精度小数基本数据类型,有效值范围从-3.40E+38到3.40E+38,占用4个字节空间.|
|小数|double|双精度小数基本数据类型,有效值范围从-1.7E+308到1.7E+308,占用8个字节空间.|
|逻辑型|bool|逻辑型基本数据类型,有效值为真/假.|
|文本型|string|文本型基本数据类型,用作记录一段字符串文本.|
|模板类型1 -> 模板类型8||模板数据类型,只能在[模板基础类](#)中使用,其所对应的真实数据类型需要由[模板实现类](#)来提供.|

各种数值数据类型的容量从小到大排列:

> 字节 < 短整数 < 字符 < 整数 < 长整数 < 小数

数值计算表达式的最终数据类型确定方法:

> 为数值计算表达式中具有最大容量的数值数据类型

##### 2\. 名称关键字:

| | | |
|---|---|---|
|**名称**|**输入字1**|**解释**|
|**对象名称关键字:**|
|本对象|this|用作在类成员方法中代表所处类的对象本身|
|父对象|super|用作在类成员方法中代表所处类的父对象,注意本关键字只能在句点操作符的第一个参数位置处使用.|
|**立即数名称关键字:**|
|真|true|用作代表逻辑值真|
|假|false|用作代表逻辑值假|
|空对象|null|用作代表空对象,可以匹配所有非常量类的类数据类型以及文本型.|

##### 3\. 操作符关键字:

| | | | | | | |
|---|---|---|---|---|---|---|
|**名称**|**特性**|**优先级**|**输入字1**|**首/左侧参数**|**右侧参数**|**解释**|
|.|\[可扩展\]|1||欲访问类/类对象名称|欲访问类成员名称|句点分隔操作符,用作分隔类/类对象与其成员名称.|
|\[\]|\[只能为参数\] <br> \[可扩展\]|1||欲访问数组数据|\[整数\] 欲访问数组成员索引值|数组成员访问操作符,用作访问所指定索引位置处的数组成员. <br> 数组成员访问索引值从0开始,有效范围为从0到数组成员数-1,分别对应数组的第一个和最后一个成员.|
|\-|\[只能为参数\] <br> \[右结合\]|2||\[数值\] 欲取反的数值||算术取反操作符,用作返回将指定数值进行符号翻转后的结果值.|
|强制类型转换|\[只能为参数\] <br> \[右结合\]|2||欲转换到数据类型名称|欲转换数据类型的数据|类型强转操作符,用作将数据转换到所指定的数据类型. <br> 调用格式为: **(欲强行转换到的数据类型)欲转换类型的数据** <br> 允许以下数据类型之间进行强制转换: <br> > **1\.** "空对象"可以强制转换到任何非常量类的类数据类型或文本型; <br> >  <br> > **2\.** 数值数据类型之间可以强行转换; <br> >  <br> > **3\.** 常量类可以强制转换到其所对应的基本数据类型,非立即数基本数据类型数据可以强制转换到对应的常量类; <br> >  <br> > **4\.** 类数据类型只能强制转换到其直接/间接基础类或继承类.|
|\*|\[只能为参数\] <br> \[可扩展\]|3||\[数值\] 被乘数|\[数值\] 乘数|算术相乘操作符,用作计算两个数值的相乘结果.|
|/|\[只能为参数\] <br> \[可扩展\]|3||\[数值\] 被除数|\[数值\] 除数|算术相除操作符,用作计算两个数值的相除结果.|
|%|\[只能为参数\]|3||算术模除操作符,用作计算两个整数的相除后的余数.|
|+|\[只能为参数\] <br> \[可扩展\]|4||\[数值/文本\] 被加数|\[数值/文本\] 加数|相加操作符,用作计算两个数值/文本的相加结果.|
|\-|\[只能为参数\] <br> \[可扩展\]|4||\[数值\] 被减数|\[数值\] 减数|算术相减操作符,用作计算两个数值的相减结果.|
|<=|\[只能为参数\]|5||\[数值\] 被比较数值|\[数值\] 比较数值|小于等于逻辑比较操作符,当左侧参数小于等于右侧参数时返回真.|
|\>=|\[只能为参数\]|5||大于等于逻辑比较操作符,当左侧参数大于等于右侧参数时返回真.|
|<|\[只能为参数\]|5||小于逻辑比较操作符,当左侧参数小于右侧参数时返回真.|
|\>|\[只能为参数\]|5||大于逻辑比较操作符,当左侧参数大于等于右侧参数时返回真.|
|属于|\[只能为参数\]|5|instanceof|\[对象\] 被检查对象|用作检查的类名|返回左侧对象是否为右侧类或者其直接/间接继承类的实例对象,即左侧对象能否被安全转换到右侧类数据类型. <br> 注意: 左侧对象的数据类型必须为类,而且必须与右侧类之间存在继承/被继承关系或者等于右侧类.|
|\==|\[只能为参数\]|6||\[数值/逻辑型/文本/数组/对象\] 被比较值|\[数值/逻辑型/文本/数组/对象\]  比较值|等于/不等于逻辑比较操作符,当左侧参数等于/不等于右侧参数时返回真. <br> **注意:** <br> > **1\.** 对于数组对象,唯一能够与其进行比较的是"空对象"; <br> >  <br> > **2\.** 对于文本数据,将比较两者实际文本内容是否相同(区分字母大小写),也可以将文本数据与"[空对象](#)"进行比较; <br> >  <br> > **3\.** 类对象比较仅比较两者是否指向同一个对象实例,而不会去对比两者所指向对象实例中存放的数据内容是否相同(火山安卓平台比较两个对象是否参考到同一对象实例,火山视窗平台比较两个对象的所处地址是否相同). <br> >  <br> > > 注意,在火山视窗平台中: <br> > >  <br> > > **A.** 如欲比较两个对象的数据内容是否相同,可以使用系统类库中所提供的"**对象内容是否相同**"全局方法; <br> > >  <br> > > **B.** "**字节集类**"是一个特例,该类的对象之间进行比较将比较两者的实际数据内容是否相同.|
|!=|\[只能为参数\]|6||
|&&|\[只能为参数\] <br> \[可扩展\]|7|且|\[逻辑型\] 逻辑值一|\[逻辑型\] 逻辑值二|并且逻辑操作符,当左侧参数和右侧参数均为逻辑值真时返回真.|
|//|\[只能为参数\]|8|或|或者逻辑操作符,当左侧参数和右侧参数其中任意一个为逻辑值真时返回真.|
|\=|\[右结合\]|9||赋值到的变量/可写属性|用作提供赋值用数据|赋值操作符,将右侧参数的值赋予给左侧参数所指定的变量/可写属性.|

注释:

> **1\.** 表格中的优先级值越小表明该操作符优先级越高;
> 
> **2\.** "特性"列中的"**\[只能为参数\]**"表示该操作符只能位于语句参数中; "**\[右结合\]**"表示 操作符参数为右结合,"**\[可扩展\]**"表明右侧参数可以被扩展多个.

##### 4\. 命令关键字:

| | | | | | | | |
|---|---|---|---|---|---|---|---|
|**名称**|**特性**|**输入字1**|**参数类型**|**参数名称**|**参数解释**|**返回值**|**解释**|
|**循环类关键字:**|
|判断循环|\[需求语句体\]|while|逻辑型|判断值|当此参数值为真时进入循环体,为假时将跳过循环体.||本命令根据提供的逻辑参数的值,来决定是否进入循环体.如果提供的逻辑参数值为真,程序顺序执行下一条语句进入循环体,否则跳转到本命令循环体的下一条语句处.|
|循环|\[需求语句体\] <br> \[隐藏空参数表\]|for|整数|\[可省略\] 变量起始值|定义循环变量的起始数值. <br> 如果被省略,默认值为0.||本命令将利用变量对循环体内的命令进行循环执行.第一次执行此命令时将使用"变量起始值"参数初始化"循环变量"参数所指定的变量.每次(包括第一次)执行到此命令处都将判断循环变量内的值是否已经到达"变量目标值"参数所指定的值,如已等于或超过,则跳转到循环体的下一条语句处,否则进入循环体.|
|整数|\[可省略\] 变量目标值|定义循环变量的目标数值,在循环首部如果发现循环变量值已到达此目标值时(递增值小于0时**小于等于**目标值,递增值大于0时**大于等于**目标值)将跳出循环 而不再进入循环体. <br> 如果被省略,默认值为1.|
|整数|\[可省略\]\[需求可写变量\] 循环变量|本整数型变量将用作控制循环执行次数,在循环尾部将自动递增或递减该变量内的数值(由变量递增值参数决定).循环体中的用户程序可以直接取用此变量中的值. <br> 如果被省略,将自动使用内部临时变量.|
|整数|\[可省略\]\[需求立即数\] 变量递增值|每次执行到循环尾部时都将把此值加入到循环变量中去,此值可为正数或负数,如为正数则递增,为负数则递减. <br> 注意: 必须为本参数提供非0整数立即值,以便编译器建立循环结束条件. <br> 如果被省略,则默认值为1.|
|**流程控制类关键字:**|
|如果|\[需求语句体\]|if|逻辑型|判断条件|本条件值的结果决定下一步程序执行位置||本命令根据所提供逻辑参数的值,来决定是否改变程序的执行位置.如果提供的逻辑参数值为真,程序继续顺序向下执行进入本命令的子语句体,然后跳过本命令后续所有的"否则"命令,为假则将跳过本命令的子语句体.|
|否则|\[需求语句体\] <br> \[隐藏空参数表\]|elseif|逻辑型|判断条件|本条件值的结果决定下一步程序执行位置. 注意: 本参数可忽略以不提供,但是此时不能再后续跟随其它的"否则"语句.||本命令只能放在"如果"或其它"否则"命令的后面,根据所提供逻辑参数的值,来决定是否改变程序的执行位置.如果提供的逻辑参数值为真,程序继续顺序向下执行进入本命令的子语句体,然后跳过本命令后续所有的"否则"命令,为假则将跳过本命令的子语句体.|
|到循环尾|\[隐藏空参数表\]|continue|||||本命令转移当前程序执行位置到当前所处循环体的尾部|
|跳出循环|\[隐藏空参数表\]|break|||||本命令转移当前程序执行位置到当前所处循环体尾部的下一条语句处|
|返回|\[隐藏空参数表\]|return||\[可省略\] 返回值|当所处方法定义有非空返回值数据类型时,必须提供返回到调用方的具体值,否则必须省略掉本参数,即两者必须对应.||本命令转移当前程序执行位置到调用本语句所处方法的下一条语句处,并可根据需要返回一个值到调用语句处.|
|**运算类关键字:**|
|取反|||逻辑型|待取反逻辑值|提供将其反转的逻辑值|逻辑型|将所指定逻辑值进行反转,返回反转后的结果.|
|位取反|||所有整数型|待取反整数值|提供将其所有位反转的整数值|对应整数型|将所指定整数值的每一位进行反转,返回反转后的结果.|
|位与|||所有整数型|整数参数一|提供用作位操作的整数参数值一|对应整数型|将参数1的每一位与参数2的对应位进行与操作,返回运算后的结果.|
|所有整数型|整数参数二|提供用作位操作的整数参数值二|
|位或|||同"位与"|将参数1的每一位与参数2的对应位进行或操作,返回运算后的结果.|
|位异或|||将参数1的每一位与参数2的对应位进行异或操作,返回运算后的结果.|
|位左移|||所有整数型|待位移整数值|提供被位移的整数值|对应整数型|将参数1的每一位向左无符号移动参数2所指定的数目,返回运算后的结果.|
|所有整数型|位移数目|提供进行位移的位数|
|位右移|||同"位左移"|将参数1的每一位向右无符号移动参数2所指定的数目,返回运算后的结果.|
|**编译时处理关键字:**|
|编译出错||cerror|||||仅在编译程序时起作用,用作告知编译器发现了编译错误并停止编译.|
|调试类关键字:|
|调试检查||assert|逻辑型|检查值|在调试版中,当此参数值为假时,程序将中断执行并报错.||本命令的调用语句仅在程序所编译的调试版本中存在,在程序所编译的发布版中将被忽略不编译. <br> 在调试版中,当所提供的参数值为假时,程序将在此处中断执行并报错.|
|文本型|\[可省略\] 检查失败信息|指定当检查失败时(检查值参数为假)所输出的信息.如果被省略,则默认为空文本.|
|为调试版||||||逻辑型|返回当前所编译程序是否为调试版本|
|**其它:**|
|挂接事件|||对象|欲挂接其事件的对象|提供欲将其所定义事件挂接到当前类对应[事件接收方法](#)的对象||将指定对象所支持的事件挂接到当前类对象中的对应事件接收方法上. 本命令仅用作动态挂接对象事件,类及类中定义的成员对象变量除非明确指定不[自动挂接](#),均会自动挂接事件.|
|整数|标记值|用作提供欲挂接其事件的对象所对应的标记值,由用户自行定义.该值将被原值发送给事件接收方法,用作区分具体的事件来源.如果被省略,则默认为0.|
|取消事件挂接|||对象|欲取消其事件挂接的对象|提供欲取消将其所定义事件挂接到当前类对应[事件接收方法](#)的对象||不再将指定对象所支持的事件挂接到当前类对象中的对应事件接收方法上. <br> 无论是自动挂接事件还是手动调用[挂接事件](#)关键字挂接的对象,均可以调用本关键字取消其事件挂接. 事件挂接一旦取消,该对象的事件将不会再被接收到.|

注释:

> **1\.** "特性"列中的"**\[需求语句体\]**"表示该命令需要携带一个子语句体,"**\[隐藏空参数表\]**"表示当该命令的参数表为空时将被省略掉不显示;
> 
> **2\.** "参数表"列中的"**\[可省略\]**"表示该参数可以被省略不提供;"**\[需求可写变量\]**"表示必须为该参数提供一个可写入变量或参数;"**\[需求立即数\]**"表示必须为该参数提供一个立即数.

#### 五. 扩展属性表:

> **1\.** 程序成员的所有属性由基本属性和扩展属性两部分组成;
> 
> **2\.** 扩展属性有以下几种:
> 
> > **A.** 类中定义的"[属性变量](#)"扩展属性值为真的成员变量;
> > 
> > **B.** 类中定义的所有[属性写方法](#);
> > 
> > **C.** 所设置扩展属性可以是**属性的子属性**,如"可读属性1.可读属性2.可写属性3",前面的父属性必须均为可读取属性,最后一个属性必须为可写入属性;
> > 
> > **D.** 火山系统定义的[全局扩展属性](#)(属性名以'@'开头);
> > 
> > **E.** 项目插件定义的[项目扩展属性](#)(属性名以'@'开头).
> 
> **3.** 属性值可以引用程序中定义的[常量](#)或者提供对应数据类型的[立即数](#). **注意:**
> 
> > **A.** 属性数据类型为[常量类](#)时也可以直接提供对应数据类型的[立即 数](#imm_value)(下面**C**条例外). 譬如,假设属性A的数据类型为"可绘制资源"(安卓平台项目下提供),那么属性值除了可以为其提供一个同样数据类型的常量以外,还可以直接为其提供一个可绘制资源文件名字符串;
> > 
> > **B.** 如果属性指定只能从其提供的选择列表中选择属性值(譬如下面的"[@列表选择项](#)"),则属性值只能从这些列表项中选择;
> > 
> > **C.** 如果属性数据类型为[常量类](#)且该类中定义有常量成员,则属性值只能从这些常量成员中选择.

---

## 附录: 定义事件与接收事件机制

### 1. 概述

火山平台提供了一套事件机制，允许一个类（发送方）触发事件，另一个类（接收方）响应事件。这是一种松耦合的通信方式。

### 2. 定义事件 (发送方)

在发送方类中，使用 `定义事件` 属性标记一个方法，使其成为事件触发器：

```volcano
类 信息类
{
    方法 传递信息 <公开 定义事件 类型 = 整数>
    参数 姓名 <类型 = 文本型>
    参数 性别 <类型 = 文本型>
    参数 年龄 <类型 = 整数>
    {
        // 方法体通常为空
        // 调用此方法时，火山平台自动向所有订阅者发送事件
    }
}
```

**要点：**
- 方法必须标记 `定义事件` 属性
- 方法体可以为空（火山平台自动处理事件分发）
- 参数将传递给接收方

### 3. 接收事件 (接收方)

在接收方类中，定义接收事件的方法：

```volcano
类 我的主窗口 <基础类 = 窗口>
{
    变量 信息类1 <类型 = 信息类>   // 必须持有发送方类型的成员变量

    // 方法名必须遵循命名规则: 发送类名_事件方法名
    方法 信息类_传递信息 <接收事件 类型 = 整数>
    参数 来源对象 <类型 = 信息类>   // 第1个参数: 来源对象
    参数 标记值 <类型 = 整数>       // 第2个参数: 标记值
    参数 姓名 <类型 = 文本型>       // 第3个参数起: 事件定义的参数
    参数 性别 <类型 = 文本型>
    参数 年龄 <类型 = 整数>
    {
        // 处理事件
        调试输出 ("收到信息: " + 姓名)
        返回 (0)
    }
}
```

### 4. 关联规则

| 规则 | 说明 |
|------|------|
| **命名规则** | 接收方法名必须为 `发送类名_事件方法名`（如 `信息类_传递信息`） |
| **成员变量** | 接收方类中必须有发送方类型的成员变量（如 `变量 信息类1 <类型 = 信息类>`） |
| **参数顺序** | 接收方法的前两个参数固定为 `来源对象` 和 `标记值`，之后是事件定义方法的参数 |
| **自动关联** | 火山平台根据命名规则自动建立事件订阅关系，无需手动注册 |
| **返回值** | 通常返回 `0`，表示事件已处理 |

### 5. 工作流程

```
1. 发送方调用事件方法
   信息类1.传递信息 ("张三", "男", 20)
              ↓
2. 火山平台自动查找订阅者
   (根据成员变量类型和方法命名规则匹配)
              ↓
3. 接收方的事件处理方法被自动调用
   信息类_传递信息 (来源对象, 标记值, "张三", "男", 20)
```

### 6. 完整示例

```volcano
// ========== 发送方类 ==========
类 文件复制类
{
    // 定义"复制完成"事件
    方法 复制完成 <公开 定义事件 类型 = 整数>
    参数 是否成功 <类型 = 逻辑型>
    {
    }

    方法 执行复制 <公开>
    参数 源文件 <类型 = 文本型>
    参数 目标文件 <类型 = 文本型>
    {
        变量 结果 <类型 = 逻辑型>
        // ... 执行复制操作 ...
        结果 = 真
        
        // 触发复制完成事件
        复制完成 (结果)
    }
}

// ========== 接收方类 ==========
类 我的主窗口 <基础类 = 窗口>
{
    变量 复制器 <类型 = 文件复制类>   // 持有发送方实例

    方法 按钮_被单击 <接收事件 类型 = 整数>
    参数 来源对象 <类型 = 按钮>
    参数 标记值 <类型 = 整数>
    {
        复制器.执行复制 ("源.txt", "目标.txt")
        返回 (0)
    }

    // 接收事件方法: 类名_事件名
    方法 文件复制类_复制完成 <接收事件 类型 = 整数>
    参数 来源对象 <类型 = 文件复制类>
    参数 标记值 <类型 = 整数>
    参数 是否成功 <类型 = 逻辑型>
    {
        如果 (是否成功)
        {
            调试输出 ("复制成功!")
        }
        返回 (0)
    }
}
```

### 7. 注意事项

1. **命名必须精确匹配**: 接收方法名中的类名和事件名必须与发送方完全一致
2. **成员变量必须存在**: 没有成员变量持有，事件无法关联
3. **参数类型必须匹配**: 接收方法的事件参数类型必须与定义方法一致
4. **不能在C++回调中直接调用**: 由于方法名翻译问题，嵌入式C++代码中不能直接调用事件方法，需要使用 `PostMessage` 等其他机制


---

## 附录: C++嵌入代码实战技巧与常见问题

### 1. 文件操作相关

#### 1.1 使用 Windows API 读取文件

```volcano
方法 读取文件内容 <公开 类型 = 文本型>
参数 文件路径 <类型 = 文本型>
{
    变量 结果 <类型 = 文本型>
    变量 文件存在 <类型 = 逻辑型>

    @ HANDLE hFile = CreateFileW(@<文件路径>.GetText(), GENERIC_READ, FILE_SHARE_READ, NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL);
    @ if (hFile == INVALID_HANDLE_VALUE) { @<文件存在> = FALSE; }
    @ else { @<文件存在> = TRUE; }

    @ if (@<文件存在>) {
    @     DWORD fileSize = GetFileSize(hFile, NULL);
    @     if (fileSize > 0) {
    @         char* pBuffer = (char*)malloc(fileSize + 1);
    @         DWORD bytesRead;
    @         ReadFile(hFile, pBuffer, fileSize, &bytesRead, NULL);
    @         pBuffer[bytesRead] = '\0';
    @
    @         CVolMem memBuf;
    @         int utf16Len = MultiByteToWideChar(CP_UTF8, 0, pBuffer, bytesRead, NULL, 0);
    @         WCHAR* wBuffer = (WCHAR*)malloc((utf16Len + 1) * sizeof(WCHAR));
    @         MultiByteToWideChar(CP_UTF8, 0, pBuffer, bytesRead, wBuffer, utf16Len);
    @         wBuffer[utf16Len] = L'\0';
    @         @<结果> = wBuffer;
    @         free(wBuffer);
    @         free(pBuffer);
    @     }
    @     CloseHandle(hFile);
    @ }

    返回 (结果)
}
```

**要点：**
- 使用 `CreateFileW` 处理 Unicode 路径
- 使用 `@<文件路径>.GetText()` 获取火山文本型的宽字符指针
- 读取 UTF-8 文件需要用 `MultiByteToWideChar` 转换编码
- 记得释放分配的内存和关闭文件句柄

#### 1.2 获取文件时间信息

```volcano
方法 取文件创建时间 <公开 类型 = 文本型>
参数 文件路径 <类型 = 文本型>
{
    变量 结果 <类型 = 文本型>

    @ HANDLE hFile = CreateFileW(@<文件路径>.GetText(), GENERIC_READ, FILE_SHARE_READ, NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL);
    @ if (hFile != INVALID_HANDLE_VALUE) {
    @     FILETIME ftCreate;
    @     SYSTEMTIME stLocal;
    @     if (GetFileTime(hFile, &ftCreate, NULL, NULL)) {
    @         FileTimeToLocalFileTime(&ftCreate, &ftCreate);
    @         if (FileTimeToSystemTime(&ftCreate, &stLocal)) {
    @             WCHAR timeBuf[256];
    @             swprintf_s(timeBuf, 256, L"%04d-%02d-%02d %02d:%02d:%02d",
    @                 stLocal.wYear, stLocal.wMonth, stLocal.wDay,
    @                 stLocal.wHour, stLocal.wMinute, stLocal.wSecond);
    @             @<结果> = timeBuf;
    @         }
    @     }
    @     CloseHandle(hFile);
    @ }

    返回 (结果)
}
```

### 2. 目录枚举相关

#### 2.1 递归枚举目录文件

```volcano
方法 枚举目录文件 <公开>
参数 目录路径 <类型 = 文本型>
参数 结果数组 <类型 = 文本数组类>
{
    变量 文件路径 <类型 = 文本型>
    变量 是目录 <类型 = 逻辑型>
    变量 继续循环 <类型 = 逻辑型>

    @ WIN32_FIND_DATAW findData;
    @ WCHAR searchPath[MAX_PATH];
    @ wcscpy_s(searchPath, MAX_PATH, @<目录路径>.GetText());
    @ wcscat_s(searchPath, MAX_PATH, L"\\*");
    @
    @ HANDLE hFind = FindFirstFileW(searchPath, &findData);
    @ if (hFind == INVALID_HANDLE_VALUE) return;
    @
    @ WCHAR fullPath[MAX_PATH];

    @ @<继续循环> = TRUE;
    判断循环 (继续循环)
    {
        // 跳过 "." 和 ".." 目录
        @ if (findData.cFileName[0] == L'.' &&
        @     (findData.cFileName[1] == L'\0' ||
        @      (findData.cFileName[1] == L'.' && findData.cFileName[2] == L'\0'))) {
        @     if (!FindNextFileW(hFind, &findData)) @<继续循环> = FALSE;
        @     continue;
        @ }
        @
        @ wcscpy_s(fullPath, MAX_PATH, @<目录路径>.GetText());
        @ wcscat_s(fullPath, MAX_PATH, L"\\");
        @ wcscat_s(fullPath, MAX_PATH, findData.cFileName);
        @ @<文件路径> = fullPath;
        @ @<是目录> = (findData.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY) ? TRUE : FALSE;

        如果 (是目录)
        {
            枚举目录文件 (文件路径, 结果数组)  // 递归
        }
        否则
        {
            结果数组.加入成员 (文件路径)
        }

        @ if (!FindNextFileW(hFind, &findData)) @<继续循环> = FALSE;
    }

    @ FindClose(hFind);
}
```

**要点：**
- 使用 `FindFirstFileW` / `FindNextFileW` 进行目录枚举
- 必须跳过 "." 和 ".." 特殊目录
- 使用 `FILE_ATTRIBUTE_DIRECTORY` 判断是否为目录
- 记得调用 `FindClose` 关闭查找句柄

### 3. 文本处理相关

#### 3.1 提取汉字字符

```volcano
方法 文本_取汉字 <公开 类型 = 文本型>
参数 待处理文本 <类型 = 文本型>
{
    变量 结果 <类型 = 文本型>

    @ const WCHAR* pInput = @<待处理文本>.GetText();
    @ int inputLen = wcslen(pInput);
    @
    @ // 计算汉字数量
    @ int resultLen = 0;
    @ for (int i = 0; i < inputLen; i++) {
    @     WCHAR ch = pInput[i];
    @     // 基本汉字范围: 0x4E00-0x9FFF
    @     if (ch >= 0x4E00 && ch <= 0x9FFF) {
    @         resultLen++;
    @     }
    @ }
    @
    @ if (resultLen > 0) {
    @     WCHAR* pBuffer = new WCHAR[resultLen + 1];
    @     int index = 0;
    @     for (int i = 0; i < inputLen; i++) {
    @         WCHAR ch = pInput[i];
    @         if (ch >= 0x4E00 && ch <= 0x9FFF) {
    @             pBuffer[index++] = ch;
    @         }
    @     }
    @     pBuffer[resultLen] = L'\0';
    @     @<结果> = pBuffer;
    @     delete[] pBuffer;
    @ }

    返回 (结果)
}
```

### 4. 常见问题与规避

#### 4.1 火山变量赋值方式

| 数据类型 | 赋值方式 | 示例 |
|---------|---------|------|
| 文本型 | 直接赋值宽字符串 | `@<结果> = L"文本";` 或 `@<结果> = wcharPtr;` |
| 整数/长整数 | 直接赋值 | `@<数值> = 123;` |
| 逻辑型 | 使用 TRUE/FALSE | `@<标志> = TRUE;` |
| 字节集类 | 使用类方法 | `@<数据>.Alloc(size);` |

#### 4.2 获取火山变量值

| 数据类型 | 获取方式 | 示例 |
|---------|---------|------|
| 文本型 | `.GetText()` | `@<文本变量>.GetText()` 返回 `const WCHAR*` |
| 字节集类 | `.GetPtr()` / `.GetSize()` | `(BYTE*)@<数据>.GetPtr()` |
| 基本类型 | 直接使用 | `int val = @<整数变量>;` |

#### 4.3 内存管理注意事项

1. **malloc/free 配对使用**
```cpp
@ char* pBuffer = (char*)malloc(size);
@ // ... 使用 pBuffer ...
@ free(pBuffer);
```

2. **new/delete 配对使用**
```cpp
@ WCHAR* pBuffer = new WCHAR[size];
@ // ... 使用 pBuffer ...
@ delete[] pBuffer;
```

3. **Windows 句柄必须关闭**
```cpp
@ HANDLE hFile = CreateFileW(...);
@ // ... 使用 hFile ...
@ CloseHandle(hFile);

@ HANDLE hFind = FindFirstFileW(...);
@ // ... 使用 hFind ...
@ FindClose(hFind);
```

#### 4.4 编码转换

UTF-8 转 Unicode (宽字符):
```cpp
@ int utf16Len = MultiByteToWideChar(CP_UTF8, 0, utf8Str, utf8Len, NULL, 0);
@ WCHAR* wBuffer = (WCHAR*)malloc((utf16Len + 1) * sizeof(WCHAR));
@ MultiByteToWideChar(CP_UTF8, 0, utf8Str, utf8Len, wBuffer, utf16Len);
@ wBuffer[utf16Len] = L'\0';
```

Unicode 转 UTF-8:
```cpp
@ CVolMem memBuf;
@ const char* utf8Str = GetMbsText(wideStr, memBuf, NULL);
```

#### 4.5 循环控制技巧

在嵌入代码中控制火山循环：
```volcano
变量 继续循环 <类型 = 逻辑型>
@ @<继续循环> = TRUE;
判断循环 (继续循环)
{
    // 循环体
    @ if (条件) @<继续循环> = FALSE;
}
```

使用 `continue` 跳过当前迭代：
```cpp
@ if (skipCondition) {
@     if (!FindNextFileW(hFind, &findData)) @<继续循环> = FALSE;
@     continue;
@ }
```

### 5. SQLite 数据库使用注意事项

#### 5.1 SQL 语句中的文本值必须加单引号

**错误写法：**
```volcano
数据库.执行SQL语句_ ("UPDATE 用户表 SET 邮箱 = test@qq.com WHERE 姓名 = '张三'", 错误信息)
```

**正确写法：**
```volcano
数据库.执行SQL语句_ ("UPDATE 用户表 SET 邮箱 = 'test@qq.com' WHERE 姓名 = '张三'", 错误信息)
```

#### 5.2 使用参数化查询更安全

```volcano
数据库.参数化_提交SQL ("UPDATE 用户表 SET 邮箱 = ? WHERE 姓名 = ?", , 错误信息)
数据库.参数化_绑定文本 (1, "test@qq.com", )
数据库.参数化_绑定文本 (2, "张三", )
数据库.参数化_执行SQL (, 错误信息)
```

**参数化查询的优点：**
- 防止 SQL 注入攻击
- 自动处理特殊字符转义
- 代码更清晰易维护

#### 5.3 内存数据库 vs 本地文件数据库

| 类型 | 方法 | 特点 |
|------|------|------|
| 内存数据库 | `打开内存库_()` | 速度快，程序关闭后数据丢失 |
| 本地文件数据库 | `打开本地库_(路径, 打开方式, ...)` | 数据持久保存到磁盘文件 |

```volcano
// 内存数据库
数据库.打开内存库_ (, , 错误信息)

// 本地文件数据库 (保存到程序目录)
变量 数据库路径 <类型 = 文本型>
数据库路径 = 取运行目录 () + "\\data.db"
数据库.打开本地库_ (数据库路径, 0, , , 错误信息)
```

### 6. 第三方库冲突问题

#### 6.1 OpenSSL 库冲突

当同时使用多个依赖 OpenSSL 的库时（如 BBAsio库 和 SQLite数据库加密版），可能出现链接错误：
```
error LNK2005: X509_LOOKUP_xxx 已经在 libcrypto.lib 中定义
fatal error LNK1169: 找到一个或多个多重定义的符号
```

**解决方案：**
1. 避免同时使用冲突的库
2. 使用不带加密的 SQLite 版本
3. 联系库作者解决兼容性问题

### 7. 调试技巧

#### 7.1 使用调试输出

```volcano
调试输出 ("变量值: " + 到文本 (变量))
调试输出 ("文本内容: " + 文本变量)
```

#### 7.2 在嵌入代码中输出调试信息

```cpp
@ OutputDebugStringW(L"调试信息\n");
@ WCHAR buf[256];
@ swprintf_s(buf, 256, L"数值: %d\n", value);
@ OutputDebugStringW(buf);
```
