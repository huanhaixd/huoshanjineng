
# 火山"视窗项目"语法手册

## 语法格式描述文本的规则

语法格式描述文本为由以下运算符组合的一个或多个语法项构成,这些运算符的优先级按顺序从小到大递增:

- | : 备选项(在多个项目中选择其中任意一个)

- () : 分组项(提供一组备选项的集合)

- [] : 可选项(可以存在也可以不存在的项目)

- {} : 重复项(可以重复存在0到n次的项目)

- 以双引号括住的文本段: 表示为字面文本项.

以上规则与GO语言一致.

如,以下语法格式中的 hex_number 描述了十六进制整数值:
```
dec_char = "0" | "1" | "2" | "3" | "4" | "5" | "6" | "7" | "8" | "9"

hex_char = dec_char | "a" | "b" | "c" | "d" | "e" | "f" | "A" | "B" | "C" | "D" | "E" | "F"

hex_number = "0x" hex_char { hex_char }
```

## 相关名词

火山软件开发平台下面简称: **火山平台**

火山视窗软件开发平台下面简称: **视窗平台**

### 名称

火山平台中的名称必须以英文字母/下划线字符/汉字字符开头,后面跟随英文字母/下划线字符/数字/汉字字符.名称对英文字母的大小写敏感,譬如"abc","ABC"所指定的不是同一名称.

有效的名称如: "Volcano", "火山A", "_vol_火山123", 无效的名称如: "123", "#火山".

多个名称可以使用句点字符连接起来形成组合名称,譬如"火山.例程".

### 立即数

立即数用作表达一个直接的字面数据值,有以下几种:

#### 数值

支持三种格式:

1. 十进制整数或小数,小数支持使用科学计数法. 如: 123, -123, 1.2e10

2. 十六进制整数: "0x"后跟数字0-9或字母A-B(大小写无关). 如: 0x12AC3F, 0xab10

3. 字符整数值: 使用单引号括住的字符,其中的字符支持使用下方[字符串](#字符串)立即数中列出的转义符. 如'A','吴','\n','\t'.

如果欲强行指定数值的数据类型,可以使用["强制类型转换"](#操作符关键字)操作符,如"(长整数)1",提供了一个数据类型为长整数的数值立即数.

如果某整数的数值超出了整数的最大有效范围,将自动被设定为长整数数据类型. 如: 0x123456789A 将被自动认为是长整数数据类型.

#### 逻辑值

为真/假.

#### 字符串

为用双引号括住的一段文本,文本内支持使用以下以 '\\' 字符引导的转义符:

- \\b : 退格符

- \\f : 换页符

- \\r : 回车符

- \\n : 换行符

- \\t : 水平制表符

- \\' : 单引号

- \\" : 双引号

- \\\\ : 反斜杠

- \\u : 后跟1-4个十六进制字符,为所对应字符的Unicode代码值

- \\ooo : 后跟1-3个八进制字符,为所对应字符的代码字节值

- \\xx : 后跟1-2个十六进制字符,为所对应字符的代码字节值

如: "你好\n世界!" 在"你好"和"世界!"之间通过使用转义符 \\n 插入了一个换行符.

#### 数组

只能在提供数组常量/数组变量初始值时使用,为使用花括号括住的立即数的组合,如: { 1, 2 }, 多维数组可以嵌套,如: { { 1, 2 }, { 3, 4 } }

注意: 多维数组的各维成员数目必须相等,譬如如下格式的数组立即数是不允许的: { { 1, 2 }, { 3 } } ,因为其两个维的成员数目不相等.

如:
```volcano
常量 数组常量1 <类型 = "整数 []" 值 = { 1, 2, 3 }>  // 定义一个具有3个数组成员值的单维整数数组常量

变量 数组变量1 <类型 = "整数 [3]" 值 = { 1, 2 }>  // 定义一个具有3个数组成员值的单维整数数组变量,其最后一个成员为默认值0.

变量 数组变量1 <类型 = "整数 [][]" 值 = { { 1, 2 }, { 3, 4 } }>  // 定义一个具有初始值的二维整数数组变量
```

### 数据类型

1. [基本数据类型](#基本数据类型), 为以下之一: 字节, 短整数, 字符, 整数, 变整数, 长整数, 单精度小数, 小数, 逻辑型, 文本型.

2. 程序中定义的[类](#类),称为对象数据类型,可以使用其"类名"或 "所处包名" + 句点 + "类名" 的方式来访问,后面称为该类的**全名称**. 如: "我的类","程序.例程.我的类"(全名称).

3. 数组数据类型:

	数组数据类型为基本或类数据类型后面跟随一个或多个数组维定义组成.

	每个数组维定义由左右中括号("[]")组成,如果应用在变量上,可以同时在中括号内部加入具体成员数目,表示同时生成对应的数组变量实例. 如:

		单维文本数组数据类型: 文本 []

		多维整数数组数据类型: 整数 [][]

		定义具有指定成员数目的整数数组变量实例: 整数 [3], 整数 [3][3]

## 成员属性

### 成员属性表

定义程序成员时可以紧跟一个属性表,属性表内容以一个或多个以空白字符分隔的属性项组成.

	成员属性表 = "<" [ 成员属性项 { 空白字符 成员属性项 } ] ">"

	成员属性项 = 属性名称 [ "=" 属性值]

    空白字符 = " " | "\t" | "\n"

属性分为两种:

1. 系统提供的[系统属性](#系统属性);

2. 用户自己在[类](#类)里面定义的[程序属性](#程序属性).

可以在某程序成员的属性表中使用的属性:

1. 所有被该成员支持的[系统属性](#系统属性),具体支持列表在每类成员的说明处有描述;

2. 如果是[类](#类)定义成员,在该类及其所有基础类中定义的[程序属性](#程序属性);

3. 如果是[变量](#变量)定义成员,且其数据类型为类,在该类及其所有基础类中定义的[程序属性](#程序属性).

#### 属性名称

为以下格式之一:

1. 有效[名称](#名称)格式. 如: 火山Volcano

2. 以'@'字符引导的名称或组合名称,用作表达[系统扩展属性](#系统扩展属性). 如: @默认值, @视窗.布局

3. 双引号括住的任意[字符串](#字符串). 如: "火山\nVolcano"

如果属性名称与下面任一[系统基本属性](#系统基本属性)的名称冲突,则必须使用第三种方式. 如属性名称: 类型 ,由于和已有系统属性名称发生冲突,就必须使用双引号括住的格式: "类型"

#### 属性值

如果为[系统基本属性](#系统基本属性)且名称不为"值",为以下几种格式之一:

1. 有效[名称](#名称)格式文本. 如: 火山Volcano

2. 以下数据类型的有效值:

    1. 逻辑值. 如: 真, 假.

    2. 数值. 如: 123, 1.23, 0x123, -123, 1.23e3

3. [字符串](#字符串)

    当属性值无法以前面几项描述时,必须以此格式描述,系统将取用该字符串转义后的字面文本作为属性值.
    
    如属性值: 123a ,由于其不能满足前面几种方式,就必须以 "123a" 进行提供.

4. 如果没有提供属性值,则该属性的值默认为逻辑值真.

否则为以下几种格式之一:

1. 有效[名称](#名称)格式文本. 如: 火山Volcano

2. 以下数据类型的有效值:

    1. 数组. 如: { 1, 2, 3 }

    2. 逻辑值. 如: 真, 假.

    3. 文本. 如: "abc", "火山\nVol".

    4. 字符. 如: 'a', '\n', '吴'.

    5. 数值. 如: 123, 1.23, 0x123, -123, 1.23e3

3. 以'@'字符开头后跟一个[字符串](#字符串),其所对应的属性值为字符串转义后的字面文本.

    当属性值无法以前面方式描述时,必须以此格式描述.

    如属性值: 123a ,由于其不能满足前面几种方式,就必须以 @"123a" 进行提供.

4. 如果没有提供属性值,则该属性的值默认为无.

### 系统属性

系统属性分为 **系统基本属性** 和 **系统扩展属性** 两种.

#### 系统基本属性

|    名称    | 数据类型 | 可应用到的程序成员 | 注释 |                                           
|:-----------|:------|:-|:-|
| 类型       | 文本型 | 常量, 变量, 参数, 方法 | 提供成员的数据类型. 如: <br> `常量 常量1 <类型 = 整数 值 = 123>` <br> `变量 主窗口对象 <类型 = 我的主窗口类>` <br> `参数 标记值 <类型 = 整数>` <br> `方法 方法1 <类型 = 整数>` |
| 公开       | 逻辑型 | 类, 方法, 类成员常量, 类成员变量 | 指定成员是否被公开. 如: <br> `类 测试类 <公开>` <br> `方法 方法1 <公开>` <br> `常量 常量1 <公开 类型 = 整数 值 = 123>` <br> `变量 变量1 <公开 类型 = 整数>` |
| 静态       | 逻辑型 | 方法, 变量 | 指定成员是否具有"静态"属性. 如: <br> `方法 方法1 <静态>` <br> `变量 变量1 <静态 类型 = 整数>` |
| 参考       | 逻辑型 | 变量 | 本属性在视窗平台中不支持 |
| 定义事件   | 逻辑型 | 方法 | 指定方法的类别是否为"定义事件". 如: <br> `方法 方法1 <定义事件>` |
| 接收事件   | 逻辑型 | 方法 | 指定方法的类别是否为"接收事件". 如: <br> `方法 方法1 <接收事件>` |
| 属性读     | 逻辑型 | 方法 | 指定方法的类别是否为"属性读". 如: <br> `方法 方法1 <属性读>` |
| 属性写     | 逻辑型 | 方法 | 指定方法的类别是否为"属性写". 如: <br> `方法 方法1 <属性写>` |
| 基础类     | 文本型 | 类 | 提供类的基础类名称. 如: <br> `类 启动类 <公开 基础类 = 窗口程序类>` |
| 值         | 文本型 | 常量, 变量 | 提供常量或变量的初始值. 如: <br> `常量 常量1 <类型 = 整数 值 = 123>` <br> `变量 变量1 <类型 = 文本型 值 = "abc">` |
| 注释       | 文本型 | 包, 类, 常量, 变量, 参数, 方法 | 提供成员的注释文本. 如果成员属性表内具有多个本属性,将会自动以多行的方式组合在一起. 如: <br> `类 启动类 <公开 基础类 = 窗口程序类 注释 = "\t这是我的程序的启动类">` <br> `方法 方法1 <类型 = 整数 注释 = "这是我的测试方法">` |
| 返回值注释 | 文本型 | 方法 | 提供方法的返回值注释文本. 如果成员属性表内具有多个本属性,将会自动以多行的方式组合在一起. 如: <br> `方法 方法1 <类型 = 整数 返回值注释 = "\t本方法返回一个整数值">` |
| 折叠, 折叠2 | 逻辑型 | | 仅在编辑时使用,可以忽略. |
| 编辑时信息, 隐藏值属性 | 文本型 | | 仅在编辑时使用,可以忽略. |

#### 系统扩展属性

系统扩展属性的名称以'@'字符开头,分为被所有火山子平台支持的"**通用系统扩展属性**"和视窗平台扩展支持的"**视窗系统扩展属性**"两种.

##### 通用系统扩展属性

|  名称   | 数据类型 | 可应用到程序成员 | 注释 |                                           
|:--------|:------|:-|:-|
@属性变量 | 逻辑型 | 非静态类成员变量 | 本属性可以应用于非静态的类成员变量(数据类型只能是[基本数据类型](#基本数据类型)或[常量类](#常量类)数据类型)上,用作指定该成员变量是否为其所处类的属性型成员. 参见[属性变量](#属性变量). |
@常量类   | 整数   | 类 | 本属性用作指定类是否为常量类及其所对应的[基本数据类型](#基本数据类型). 参见[常量类](#常量类). |
@全局类   | 逻辑型 | 类 | 本属性用作指定类为全局类. 全局类中的所有静态公开方法在外部访问时都可以省略其类名指定. 参见[全局类](#全局类). |
@虚拟方法 | 整数   | 方法 | 本属性只能应用于普通类型的非静态方法定义成员上,用作指定该方法为虚拟方法. 参见[虚拟方法](#虚拟方法). |
@默认值   |       | 参数 | 本属性只能应用于方法的参数定义成员上,用作为参数提供调用方未提供对应数据时的默认值. 参见[方法参数](#方法参数). |

##### 视窗系统扩展属性

视窗系统扩展属性的属性名以"@视窗."开头.

|    名称    | 数据类型 | 可应用到程序成员 | 注释 |                                           
|:-----------|:------|:-|:-|
@视窗.附属文件 | 文本型 | 包/类/方法 | |
@视窗.值文件   | 文本型 | 变量 | 本属性用作提供数据类型为"文本型"或"字节集类"的变量的初始值内容. 参见[变量](#变量)中的说明. |
@视窗.布局    | 文本型 | "窗口容器组件"继承类 / 窗口组件成员变量 | 本属性用作记录窗口布局信息. 具体参见[窗口布局](#窗口布局). |

"@视窗.附属文件"说明:

本属性用作提供所处包/类/方法运行时所需求外部附属文件或目录的名称,多个文件或目录名之间使用逗号或换行符分隔.

在编译时,如果属性所应用到的程序成员被编译进最终结果(火山基于按需编译机制,未被使用的代码不会被编译进最终结果),那么对应的文件或目录(包括其中的所有文件及子目录)将被复制到编译结果文件所处的目录中,以供其运行时访问.

可以在所提供的附属文件或目录名称后加一个右尖括号'>'字符,再后跟随一个相对目录路径,该路径相对编译结果文件所处目录,会被自动创建,用作指定附属文件或目录的最终拷贝到目录位置.

譬如: "c:\abc.txt > data\txt",在编译成功后系统将会把"c:\abc.txt"复制到编译结果文件所处目录的"data\txt"子目录内.

所提供文件/目录名如果为相对路径,则将在本属性应用位置所处火山源文件的目录路径内查找.

例程:
```volcano
<火山程序 类型 = "通常" 版本 = 1 />

包 火山.例程 <注释 = "\"package_data_dir\"为本源程序文件所处目录下的子目录名,当程序编译成功后,会将该目录及其中的所有文件及子目录均复制到编译结果文件存放目录中."
        @视窗.附属文件 = "package_data_dir">

类 启动类 <公开 基础类 = 程序类 注释 = "\"class_data.txt\"为本源程序文件所处目录下的一个文件名,当程序编译成功后,会将该文件复制到编译结果文件存放目录中."
        @视窗.附属文件 = "class_data.txt">
{
    方法 启动方法 <公开 类型 = 整数 注释 = "当程序编译成功后,系统将会把\"c:\\abc.txt\"复制到编译结果文件存放目录的\"data\\txt\"子目录内."
            @视窗.附属文件 = "c:\\abc.txt > data\\txt">
    {
        返回 (1)
    }
}
```

## 程序结构

### 文档格式和版本定义行

语法格式: "<火山程序 类型 = " 类型名称 "版本 = " 版本号 "/>"

类型名称: 提供当前火山程序文档的格式类型,目前支持的有: "通常"

版本号: 提供当前火山程序文档的版本号,目前最新版本号为: 1

因此,当前最新版本的类型为"通常"的文档格式和版本定义行为:

	<火山程序 类型 = "通常" 版本 = 1 />

火山源程序首非空行必须为文档格式和版本定义行.

### 包

定义格式: "包" 包名 [成员属性表]

用作定义当前程序文件中所有[类](#类)位于的包,整个源文件中只能存在一个而且必须紧跟在[文档格式和版本定义行](#文档格式和版本定义行)的后方.

包名为以句点分隔的组合名称. 如: "火山.程序". 多个源程序文件可以使用相同名称的包,此时其中的所有类被认为处于同一个包中.

包名与类名组成了类的全名称,用作在该类所处包的外部引用它,因此包名可以被认为是类的命名空间.

如,定义一个包:
```volcano
包 火山.例程 <注释 = "本程序为一个火山例程">
```
如果该包所处源文件中定义了一个类:
```volcano
类 测试类
```
那么在"火山.例程"包的外面可以使用"火山.例程.测试类"名称来访问该类.

### 类

定义格式: "类" 类名 [成员属性表]

类是一种对象[数据类型](#数据类型),可以定义其对象实例.

引用类时可以直接使用类名称,也可以使用"包名.类名"进行全名称引用. 全名称用作在该类所处包外部引用该类,但是如果其它包中没有相同名称的类,那么也可以忽略包名直接使用类名来引用.

类的成员属性表中可以加入本类或其直接/间接基础类中定义的[程序属性](#程序属性),这些属性将在定义本类的对象实例时被自动设置.

类定义行后面可以紧随一个以花括号行(花括号必须位于单独一行上)括住的类定义体(为空可以省略),其中可以定义一系列的子成员: [方法](#方法) / [变量](#变量) / [常量](#常量)

注意: 名称为 **"启动类"** 的类为特定类,整个用户程序将从该类的"启动方法"处开始执行.

如,下面定义了一个名为"启动类"的类:
```volcano
<火山程序 类型 = "通常" 版本 = 1 />

包 火山.例程

类 启动类 <公开 基础类 = 程序类>  // 定义了名为"启动类"的类,其基础类为"程序类".
{  // 类定义体的开始,左花括号必须位于单独的一行上.
    方法 启动方法 <公开 类型 = 整数>  // 在"启动类"中定义了名为"启动方法"的成员方法,整个用户程序将从该方法处开始执行.
    {
        标准输出行 (, "我的启动类")  // "标准输出行"全局方法用作在控制台的标准输出设备上输出一行文字,其第一个参数被省略表示输出到标准输出设备,第二个参数提供被输出的文本.
        返回 (1)
    }
}  // 类定义体的结束,右花括号必须位于单独的一行上.
```

#### 所支持的[系统基本属性](#系统基本属性)

1. 基础类

	类可以单根继承一个基础类,本属性用作指定该基础类的名称,可以是空文本(此时为默认基础类: "对象类").

	类将自动继承所有来自直接/间接基础类的内容,本类称为这些基础类的"继承类".

	继承类访问其直接/间接基础类中的成员不需要其为公开状态.

2. 公开

	指定本类是否对外公开. 公开类可以在所处包外部被访问,而非公开类只能在所处包内部被访问.

	例程:
	```volcano
	<火山程序 类型 = "通常" 版本 = 1 />

	包 火山.例程

	类 启动类 <公开 基础类 = 程序类 注释 = "名称为\"启动类\"的类为特定类,整个用户程序将从该类的\"启动方法\"处开始执行.">
	{
		方法 启动方法 <公开 类型 = 整数 注释 = "整个用户程序将从\"启动类\"的启动方法处开始执行">
		{
			变量 变量1 <类型 = 演示继承类 注释 = "定义了一个\"演示继承类\"的实例变量">
			变量1.继承类方法 ()  // 调用"演示继承类"实例变量的"继承类方法"
			返回 (1)
		}
	}

	类 演示继承类 <基础类 = 演示基础类 注释 = "定义了一个名为\"演示继承类\"的类,其基础类为\"演示基础类\".">
	{
		常量 常量1 <类型 = 文本型 值 = "演示用常量" 注释 = "在当前类中定义了一个常量成员,并提供了其初始值.">

		方法 继承类方法 <公开 注释 = "在当前类中定义了一个公开方法,可以在类外部被访问.">
		{
			标准输出行 (, "继承类中的方法被调用")
			基础类方法 (常量1)  // 调用从基础类中继承过来的方法,哪怕其"公开"属性未被设置.
		}
	}

	类 演示基础类 <注释 = "定义了一个名为\"演示基础类\"的类,用作\"演示继承类\"类的基础类.该类没有定义基础类,因此其基础类为名为\"对象类\"的默认基础类."
			注释 = "注意: 本类中加入了一个名为\"标记值\"的属性,该属性是在默认基础类\"对象类\"中定义的,所设置的属性值\"123\"将在定义本类的实例对象时被自动置入." 标记值 = 123>
	{
		方法 基础类方法 <注释 = "在基础类中定义了一个方法,注意其\"公开\"属性未被设置.">
		参数 参数1 <类型 = 文本型>
		{
			标准输出行 (, "基础类中的方法被调用,参数: " + 参数1 + "; 标记值: " + 到文本 (标记值))  // 将调用时传递过来的参数和本类对象成员属性表中加入的"标记值"属性一起输出. "到文本"全局方法用作将其它数据类型的数据转换为文本型.
		}
	}
	```

	运行输出结果:
	```
	继承类中的方法被调用
	基础类中的方法被调用,参数: 演示用常量; 标记值: 123
	```

#### 常量类

类支持使用["@常量类"](#系统扩展属性)系统扩展属性,如果类的成员属性表中定义有该属性,此类被称为**常量类**.

常量类是一种伪类,它并不是真正意义上的类,实际上等效于其"@常量类"属性值所指定的[基本数据类型](#基本数据类型),"@常量类"属性值可以为以下选择项之一:

    1. 字节; 2. 短整数; 3. 字符; 4. 整数; 5. 变整数; 6. 长整数; 7. 单精度小数; 8. 小数; 9. 逻辑型; 10. 文本型.

常量类特点及注意事项:

1. 常量类用作建立指定[基本数据类型](#基本数据类型)数据的集合,该类中只允许定义数据类型为该类的[常量成员](#常量).如果类中所定义常量成员的数据类型为空,则其数据类型会自动默认为所处常量类;

2. 如果存在类的继承,常量类的基础类只能是常量类(两者所对应的[基本数据类型](#基本数据类型)必须一致),非常量类的基础类只能是非常量类,两者不能混用;

3. 数据类型为常量类的局部变量在访问前必须首先明确赋值;

4. 数据类型为常量类的常量/变量的初始值可以为常量类所对应的[基本数据类型](#基本数据类型)立即数;

5. 常量类数据类型不能与其所对应的[基本数据类型](#基本数据类型)匹配,但是可以强制转换到所对应的[基本数据类型](#基本数据类型).

例程:
```volcano
<火山程序 类型 = "通常" 版本 = 1 />

包 火山.例程

类 我的星期类 <公开 注释 = "本类为一个常量类,用作提供星期内各天的常量值." 注释 = "本类所对应基本数据类型为\"整数\",因此在程序中可以以\"整数\"数据类型的方式使用它."
        注释 = "在本类中只允许定义数据类型为该类的常量成员." @常量类 = 整数>
{
    常量 星期一 <公开 值 = 0 注释 = "此常量成员的数据类型为空,因此其数据类型默认为\"我的星期类\"自身.">
    常量 星期二 <公开 值 = 1 注释 = "因为本常量类所对应的基本数据类型为整数,因此可以直接使用整数值作为其初始值.">
    常量 星期三 <公开 类型 = 我的星期类 值 = 2 注释 = "也可以明确将数据类型写明为当前常量类,不过这是多余的.">
    常量 星期四 <公开 值 = 3>
    常量 星期五 <公开 值 = 4>
    常量 星期六 <公开 值 = 5>
    常量 星期日 <公开 值 = 6>
}

类 启动类 <公开 基础类 = 程序类 注释 = "名称为\"启动类\"的类为特定类,整个用户程序将从该类的\"启动方法\"处开始执行.">
{
    方法 启动方法 <公开 类型 = 整数 注释 = "整个用户程序将从\"启动类\"的启动方法处开始执行">
    {
        变量 变量1 <类型 = 我的星期类 注释 = "定义一个数据类型为常量类的局部变量.">
        变量1 = 我的星期类.星期五  // 由于"变量1"为局部变量且其数据类型为常量类,因此在使用前必须首先明确赋值.
        方法1 (我的星期类.星期六, 变量1)  // 调用方法,将常量类中的常量值传递过去.
        返回 (1)
    }

    方法 方法1
    参数 参数1 <类型 = 我的星期类 注释 = "本参数接收一个数据类型为\"我的星期类\"的值">
    参数 参数2 <类型 = 我的星期类>
    {
        标准输出行 (, 到文本 ((整数)参数1) + ", " + 到文本 ((整数)参数2))  // 常量类可以强行转换为对应的基本数据类型
        如果 (参数2 == 我的星期类.星期五)
        {
            标准输出行 (, "所提供参数2的值为\"星期五\"")
        }
    }
}
```

运行输出结果:
```
5, 4
所提供参数2的值为"星期五"
```

#### 全局类

类支持使用["@全局类"](#系统扩展属性)系统扩展属性,如果类的成员属性表中定义有值为真的该属性,此类被称为**全局类**.

全局类中的所有静态公开方法在外部访问时都可以省略其类名指定,即由"类名.方法名"的形式改为直接使用方法名,此类方法被称为 **"全局方法"**.

例程:
```volcano
<火山程序 类型 = "通常" 版本 = 1 />

包 火山.例程

类 我的全局类 <公开 注释 = "本类为一个全局类,类中的所有静态公开方法在类外部可以直接以\"方法名\"的方式访问" 注释 = "" @全局类 = 真>
{
    方法 全局方法1 <公开 静态 注释 = "定义了一个静态公开方法,由于其位于全局类中,因此在外部可以直接以\"全局方法1\"而不是\"我的全局类.全局方法1\"的方式访问.">
    {
        标准输出行 (, "全局方法被调用")
    }
}

类 启动类 <公开 基础类 = 程序类>
{
    方法 启动方法 <公开 类型 = 整数>
    {
        全局方法1 ()  // "全局方法1"定义在全局类中,因此可以直接以\"全局方法1\"而不是\"我的全局类.全局方法1\"的方式调用.
        返回 (1)
    }
}
```

运行输出结果:
```
全局方法被调用
```

### 常量

定义格式: "常量" 常量名 [成员属性表]

常量用作定义一个不允许在程序中进行修改的恒定值. 常量可以在类或方法中被定义,前者称为类的**成员常量**,后者称为**局部常量**.

**局部常量的作用域**: 从所处代码块中常量定义位置处开始一直到所处代码块尾部. 如:

```volcano
变量1 = 常量1  // 错误: "常量1"从其定义位置处开始才会有效

常量 常量1 <类型 = 整数 值 = 1>  // 定义"常量1"

变量1 = 常量1  // 正确: "常量1"从其定义位置处开始即有效

循环
{
    变量1 = 常量1  // 正确: "常量1"在其所处代码块的子代码块中亦有效

    常量 常量2 <类型 = 整数 值 = 1>  // 定义"常量2"

    变量1 = 常量2  // 正确: "常量2"从其定义位置处开始即有效
}

变量1 = 常量2  // 错误: "常量2"已经超出了其所处代码块的尾部,不再有效.
```

#### 所支持的[系统属性](#系统属性)

1. 类型

	提供常量的数据类型,只能是[基本数据类型](#基本数据类型)或[常量类](#常量类). 如,定义一个文本常量: `常量 常量1 <类型 = 文本型 值 = "演示用常量">`

	本属性必须存在且提供了有效数据类型.

2. 公开

	如果本常量为成员常量,指定其是否公开. 公开成员常量可以在所处类外部通过"类名.常量名"的方式来访问,而非公开成员常量只能在本类或者其继承类中访问. 局部常量没有本属性.

	如,定义一个公开的成员常量: `常量 常量1 <公开 类型 = 文本型 值 = "演示用常量">`

3. 值

	提供常量的初始值[立即数](#立即数). 注意:
	
	1. 定义常量时必须同时提供初始值;

	2. 所提供值必须能够匹配常量的数据类型;

	3. 只能为[立即数](#立即数),不能引用其它常量;

	4. 不能以"常量 = xxx"的格式设置常量初始值,只能通过本属性来设置.

	如:
	```volcano
	常量 常量1 <类型 = 整数 值 = 1>  // 正确

	常量 常量1 <类型 = 整数>  // 错误: 没有同时提供初始值
	
	常量 常量1 <类型 = 整数 值 = "文本值">  // 错误: 初始值必须与常量的数据类型匹配

	常量 常量1 <类型 = 整数 值 = 常量2>  // 错误: 初始值不能引用其它常量

	常量 常量1 = 1  // 错误: 必须使用"值"属性而不是直接赋值的方式来提供初始值
	```

### 变量

定义格式: "变量" 变量名 [成员属性表]

变量的内容允许在程序中被动态修改. 变量可以在类或方法中被定义,前者称为类的**成员变量**,后者称为**局部变量**.

#### 局部变量的作用域

局部变量的作用域从所处代码块中变量定义位置处开始一直到所处代码块尾部. 如:

```volcano
变量1 = 1  // 错误: "变量1"从其定义位置处开始才会有效

变量 变量1 <类型 = 整数>  // 定义"变量1"

变量1 = 2  // 正确: "变量1"从其定义位置处开始即有效

循环
{
    变量1 = 3  // 正确: "变量1"在其所处代码块的子代码块中亦有效

    变量 变量2 <类型 = 整数>  // 定义"变量2"

    变量2 = 4  // 正确: "变量2"从其定义位置处开始即有效
}

变量2 = 5  // 错误: "变量2"已经超出了其所处代码块的尾部,不再有效.
```

#### 所支持的[系统属性](#系统属性)

1. 类型

	提供变量的[数据类型](#数据类型). 如,定义一个文本变量: `变量 变量1 <类型 = 文本型>`

	本属性必须存在且提供了有效数据类型.

2. 静态

	指定是否为静态变量,静态变量在所处类载入后即保持始终存在. 类的静态成员变量在外部应该通过"类名.变量名"的方式来引用.

	由于静态变量初始化时不存在所处类实例,因此其不支持自动挂接事件到所处类,在需要时必须通过"挂接事件"命令手动挂接. 非静态的类成员变量,如果其数据类型为类且其中定义有事件,将被自动挂接到当前类实例对象. 参见后面有关[动态挂接事件](#动态挂接事件)的描述.

	如:
	```volcano
	变量 变量1 <静态 类型 = 整数>  // 定义一个整数静态变量

	类1.静态变量1 = 123  // 设置位于"类1"中的"静态变量1"的值
	```

3. 公开

	如果本变量为成员变量,指定其是否公开. 公开成员变量可以在所处类外部通过"类名.变量名"的方式来访问,而非公开成员变量只能在本类或者其继承类中访问. 局部变量没有本属性.

	如,定义一个公开的成员变量: `变量 变量1 <公开 类型 = 文本型>`

4. 值

	提供变量的初始值. 注意:
	
	1. 所提供初始值必须能够匹配变量的数据类型;

	2. 初始值可以为[立即数](#立即数)或[常量](#常量);

	3. 如果未提供初始值,数值型变量的初始值为0,逻辑型变量的初始值为假,文本型变量的初始值为空文本;

	4. 不能以"变量 = xxx"的格式设置变量初始值,只能通过本属性来设置.

	如:
	```volcano
	变量 变量1 <类型 = 整数 值 = 1>  // 正确

	变量 变量1 <类型 = 整数 值 = 类1.常量1>  // 正确: 变量初始值中可以引用常量

	变量 变量1 <类型 = 整数 值 = "文本值">  // 错误: 初始值必须与变量的数据类型匹配
	
	变量 变量1 = 1  // 错误: 必须使用"值"属性而不是直接赋值的方式来提供初始值
	```

5. @视窗.值文件

	本属性用作提供数据类型为"文本型"或"字节集类"的变量的初始值内容.

	属性值为一个文件名,该文件中的内容在编译时将被读入整合进编译结果文件中,并用作所指定变量的初始值.

	注意:

	1. 当变量数据类型为"文本型"时,所提供文件必须为Unicode-16字符集格式的文本文件;

	2. 当变量数据类型为"字节集类"时,所提供文件可以是任意二进制文件;

	3. 所提供文件名如果为相对路径,为相对于本属性应用位置所处火山源文件的目录位置;

	4. 所提供的值文件内容将被直接整合进入所编译项目的结果文件资源段中,发布时不再需要单独携带.

	例程:
	```volcano
	<火山程序 类型 = "通常" 版本 = 1 />

	包 火山.例程

	类 启动类 <公开 基础类 = 程序类>
	{
		方法 启动方法 <公开 类型 = 整数>
		{
			变量 变量1 <类型 = 文本型 注释 = "\"content.txt\"为一个Unicode-16字符集的文本文件,其中的内容为: \"这是来自文件中的内容\", 此内容将被读入并作为变量1的初始值."
					@视窗.值文件 = "content.txt">
			标准输出行 (, 变量1)  // 在控制台上输出变量1的初始内容
			返回 (1)
		}
	}
	```

	运行输出结果:
	```
	这是来自文件中的内容
	```

### 方法

定义格式: "方法" 方法名 [成员属性表]

方法如果存在参数,所有参数的定义行必须紧跟在方法定义行的后面,其定义格式为:

    "参数" 参数名 [成员属性表]

方法及其参数定义行后可以紧随一个以花括号行(花括号必须位于单独一行上)括住的方法定义体(为空可以省略),其中可以定义一系列的子成员: [局部变量](#变量) / [局部常量](#常量) / [方法语句行](#方法语句行)

如,下面定义了一个计算返回2个整数和的方法:
```volcano
<火山程序 类型 = "通常" 版本 = 1 />

方法 求和 <类型 = 整数>  // 方法定义行
参数 参数1 <类型 = 整数>  // 定义方法的参数,必须紧跟在方法定义行的后面.
参数 参数2 <类型 = 整数>  // 继续列出所有参数定义行
{  // 方法定义体的开始,左花括号必须位于单独的一行上.
    返回 (参数1 + 参数2)  // 方法语句,计算并返回两个参数的和.
}  // 方法定义体的结束,右花括号必须位于单独的一行上.
```

#### 所支持的[系统基本属性](#系统基本属性)

1. 类型

	提供方法返回值的[数据类型](#数据类型). 如,定义一个返回文本的方法: `方法 方法1 <类型 = 文本型>`

	如果方法没有返回值,可以不提供本属性.

2. 静态

	指定是否为静态方法. 注意:

	1. 类的静态方法需要通过"类名.方法名"的方式来引用;

	2. 在静态方法内部，只能访问其所处类或者所处类的基础类中的成员常量或者静态成员变量;

	3. 如果静态方法所定义第一个参数的数据类型为方法所处类本身,那么可以基于该类对象以动态格式来调用该静态方法,编译器将自动进行转换. 如: 假设"类1"中定义了"静态方法1",而"静态方法1"的第一个参数的数据类型为"类1",类似这样的静态调用格式"类1.静态方法1 (类1对象, ...)"可以以"类1对象.静态方法1 (...)"的动态调用格式进行书写.

3. 公开

	指定本方法是否公开.公开方法可以在所处类外部被访问,而非公开方法只能在本类或者其继承类中访问.

	如,定义一个公开的方法: `方法 方法1 <公开>`

4. 类别

	方法可以具有如下类别:

	1. 通常: 表明本方法为通常方法

	2. 属性读 / 属性写: 表明本方法为属性读/写方法,具体请见下面的"[属性方法](#属性方法)"节;

	3. 定义事件 / 接收事件: 表明本方法为事件的定义或接收方法,具体请见下面的"[事件](#事件)"节.

#### 虚拟方法

可以将"@虚拟方法"属性应用于类别为"通常"的非静态方法上,用作指定该方法为虚拟方法. 使用虚拟方法可以支持类的多态性.

虚拟方法可以在其继承类中被覆盖,继承类中用作覆盖的虚拟方法必须与基础类中对应虚拟方法的名称/公开状态/返回值/参数表完全相同.

属性值为以下选项值之一:

1. 可覆盖: 为可覆盖虚拟方法,继承类可以通过定义与本方法同名同返回值同参数表的虚拟方法来覆盖本方法;

2. 不可覆盖: 为不可覆盖虚拟方法,继承类不能覆盖本方法.

例程:
```volcano
<火山程序 类型 = "通常" 版本 = 1 />

包 火山.例程

类 启动类 <公开 基础类 = 程序类>
{
    方法 启动方法 <公开 类型 = 整数>
    {
        变量 变量1 <类型 = 基础类1 注释 = "定义一个\"基础类1\"的变量实例">
        变量 变量2 <类型 = 继承类1 注释 = "定义一个\"继承类1\"的变量实例">
        方法1 (变量1)  // 将"基础类1"的变量实例传递到"方法1"的"参数1"来调用该方法,因此在"方法1"中被调用的"虚拟方法1"为在"基础类1"中定义的覆盖虚拟方法,最终将输出: "基础类1"中的虚拟方法被调用
        方法1 (变量2)  // 将"继承类1"的变量实例传递到"方法1"的"参数1"来调用该方法,因此在"方法1"中被调用的"虚拟方法1"为在"继承类1"中定义的覆盖虚拟方法,最终将输出: "继承类1"中的虚拟方法被调用
        返回 (1)
    }

    方法 方法1
    参数 参数1 <类型 = 基础类1 注释 = "接收一个数据类型为\"基础类1\"的对象." 注释 = "1. 由于基础类数据类型可以匹配其继承类的数据类型,因此也可以将\"继承类1\"的对象实例传递过来."
            注释 = "2. 由于数据类型为类的参数,都是以参考方式传递数据,因此此处的\"参数1\"也可能实际指向的是\"继承类1\"的对象实例.">
    {
        参数1.虚拟方法1 ()  // 此处调用"虚拟方法1"的"参数1",其实际数据类型由调用方提供,即有可能为"基础类1"对象,也有可能为"继承类1"对象.
    }
}

类 基础类1
{
    方法 虚拟方法1 <公开 注释 = "定义一个虚拟方法,支持在本类的继承类中将其覆盖." @虚拟方法 = 可覆盖>
    {
        标准输出行 (, "\"基础类1\"中的虚拟方法被调用")
    }
}

类 继承类1 <基础类 = 基础类1 注释 = "本类的基础类为\"基础类1\"">
{
    方法 虚拟方法1 <公开 注释 = "本方法覆盖了本类的基础类\"基础类1\"中定义的\"虚拟方法1\"" @虚拟方法 = 可覆盖>
    {
        标准输出行 (, "\"继承类1\"中的虚拟方法被调用")
    }
}
```

运行输出结果:
```
"基础类1"中的虚拟方法被调用
"继承类1"中的虚拟方法被调用
```

#### 类的初始化和清理方法

名称为 **"类_初始化"** 的方法为类的初始化方法(在类对象实例被创建时自动调用),该方法不携带任何参数并且不返回值,对是否公开没有要求.

名称为 **"类_清理"** 的方法为类的清理方法(在类对象实例被销毁时自动调用),该方法不携带任何参数并且不返回值,对是否公开没有要求.

例程:
```volcano
<火山程序 类型 = "通常" 版本 = 1 />

包 火山.例程

类 启动类 <公开 基础类 = 程序类>
{
    方法 启动方法 <公开 类型 = 整数>
    {
        方法1 ()
        返回 (1)
    }

    方法 方法1
    {
        变量 变量1 <类型 = 类1 注释 = "定义了\"类1\"的实例变量,此时其\"类_初始化\"方法将被自动调用以手动初始化其内容.">
        标准输出行 (, "执行方法中的功能")
        // 在当前方法返回时,"变量1"由于超出作用域被自动销毁,其"类_清理"将被自动调用.
    }
}

类 类1
{
    方法 类_初始化 <注释 = "定义\"类1\"的初始化方法,其将在建立\"类1\"的对象实例后自动被调用.">
    {
        标准输出行 (, "类的初始化方法被调用")
    }

    方法 类_清理 <注释 = "定义\"类1\"的清理方法,其将在\"类1\"的对象实例被销毁时自动被调用.">
    {
        标准输出行 (, "类的清理方法被调用")
    }
}
```
运行输出结果:
```
类的初始化方法被调用
执行方法中的功能
类的清理方法被调用
```

#### 方法参数

方法参数为方法提供参数定义信息.

##### 所支持的[系统属性](#系统属性)

1. 类型

	提供参数的[数据类型](#数据类型). 如,定义一个文本参数: `参数 参数1 <类型 = 文本型>`

	本属性必须存在且提供了有效数据类型.

2. @默认值

	本属性用作为参数提供调用方未提供对应数据时的默认值,所设置数据必须与参数数据类型匹配.

	当本属性应用到数据类型为数组/类/文本型的参数时,可以将属性值设置为"空对象".

	例程:
	```volcano
	<火山程序 类型 = "通常" 版本 = 1 />

	包 火山.例程

	类 启动类 <公开 基础类 = 程序类>
	{
		方法 启动方法 <公开 类型 = 整数>
		{
			方法1 (, "所传递参数值2")  // 参数1和参数3使用默认值,参数2使用所指定值.
			返回 (1)
		}

		方法 方法1
		参数 参数1 <类型 = 文本型 注释 = "提供默认值的参数" @默认值 = "默认参数值1">
		参数 参数2 <类型 = 文本型 注释 = "此参数没有提供默认值" "">
		参数 参数3 <类型 = 文本型 注释 = "提供默认值的参数" @默认值 = "默认参数值3">
		{
			标准输出行 (, 参数1 + ", " + 参数2 + ", " + 参数3)
		}
	}
	```

	运行输出结果:
	```
	默认参数值1, 所传递参数值2, 默认参数值3
	```

##### 参数的传递方式

方法参数的传递方式分为传址和传值两种:

- 传址方式: 传递调用方所提供参数数据的参考,在方法内修改所传递参数的内容也会同时修改调用方对应的参数数据内容;

- 传值方式: 传递调用方所提供参数数据的复制值,在方法内修改所传递参数的内容不会修改调用方对应的参数数据内容.

所有除开文本型之外的[基本数据类型](#基本数据类型)均采用传值的方式,其它数据类型(对象数据类型,文本型)均采用传址方式.

请注意: 视窗平台不支持方法返回值/参数为数组数据类型,如需使用请使用系统类库中所提供的对应数组类进行替代.

例程:
```volcano
<火山程序 类型 = "通常" 版本 = 1 />

包 火山.例程

类 启动类 <公开 基础类 = 程序类>
{
    方法 启动方法 <公开 类型 = 整数>
    {
        变量 变量1 <类型 = 文本型 值 = "调用方数据">
        变量 变量2 <类型 = 类1 "">
        变量 变量3 <类型 = 整数>
        变量2.成员1 = 1  // 设置对象的成员初始值
        变量3 = 3
        标准输出行 (, 变量1 + ", " + 到文本 (变量2.成员1) + ", " + 到文本 (变量3))  // 输出当前所设置的初始值,用作后面对比.
        方法1 (变量1, 变量2, 变量3)  // 将这三个变量作为参数调用"方法1"
        标准输出行 (, 变量1 + ", " + 到文本 (变量2.成员1) + ", " + 到文本 (变量3))  // 输出"方法1"修改后的结果
        返回 (1)
    }

    方法 方法1
    参数 参数1 <类型 = 文本型>
    参数 参数2 <类型 = 类1 "">
    参数 参数3 <类型 = 整数>
    {
        参数1 = "方法1修改值"  // 文本型的参数采用传址的方式传递数据,修改此参数值将同步修改调用方的数据.
        参数2.成员1 = 200  // 类数据类型的参数采用传址的方式传递数据,修改此参数值将同步修改调用方的数据.
        参数3 = 400  // 整数型的参数采用传值的方式传递数据,修改此参数值不会影响调用方的数据.
    }
}

类 类1
{
    变量 成员1 <公开 类型 = 整数>
}
```

运行输出结果:
```
调用方数据, 1, 3
方法1修改值, 200, 3
```

### 程序属性

在类中可以定义属性,所定义属性可以在该类自身或该类对象实例变量的成员属性表中使用.

在该类自身的成员属性表中被使用时,属性在创建新的类对象实例时被自动设置.

在该类对象实例变量的成员属性表中被使用时,属性在创建该对象实例变量时被自动设置.

类的属性分为以下两种:

#### 属性变量

如果类成员变量的成员属性表中存在值为真的["@属性变量"](#通用系统扩展属性)系统属性,则该成员变量称为"属性变量".

应用此属性的类成员变量必须为非静态变量,其数据类型必须为[基本数据类型](#基本数据类型)或[常量类](#常量类)数据类型.

例程:
```volcano
<火山程序 类型 = "通常" 版本 = 1 />

包 火山.例程

类 启动类 <公开 基础类 = 程序类>
{
    方法 启动方法 <公开 类型 = 整数>
    {
        变量 变量1 <类型 = 类1 注释 = "定义\"类1\"的实例变量,并同时在其成员属性表中指定\"属性2\"的值." 属性2 = 200>
        标准输出行 (, 到文本 (变量1.属性1) + ", " + 到文本 (变量1.属性2))  // 输出所设置的属性值. "属性1"在"类1"自身的成员属性表中被设置,"属性2"在定义"变量1"时被设置.
        返回 (1)
    }
}

类 类1 <注释 = "在类自身的成员属性表中可以使用自身定义的属性,该属性将在创建类对象实例时被自动设置." 属性1 = 100>
{
    变量 属性1 <公开 类型 = 整数 注释 = "定义属性变量" @属性变量 = 真>
    变量 属性2 <公开 类型 = 整数 @属性变量 = 真>
}
```

运行输出结果:
```
100, 200
```

#### 属性方法

可以通过将方法的类别设置为"属性读"或"属性写"来将其声明为属性读/写方法. 注意:

1. 可以只定义单个属性读或写方法. 只定义了属性读方法而没定义属性写方法则此属性只读,只定义了属性写方法而没定义属性读方法则此属性只写.

2. 在[全局类](#全局类)中不能定义属性读/写方法.

##### 属性读方法

如果属性读方法为静态方法,所要求的定义格式:

1. 必须定义且只能定义一个参数,该参数的数据类型必须为属性读方法所处类本身;

2. 必须定义有返回值,该返回值的数据类型不能为数组,该数据类型即为本属性被读取时的数据类型.

如果属性读方法为非静态方法,所要求的定义格式:

1. 不能定义参数;

2. 必须定义有返回值,该返回值的数据类型不能为数组,该数据类型即为本属性被读取时的数据类型.

注意:

1. 在程序中,必须以与变量相同的引用方式来访问属性读方法. 如: `类对象1.属性1`;

2. 如果存在同名属性写方法,则两者的数据类型必须一致;

##### 属性写方法

如果属性写方法为静态方法,所要求的定义格式:

1. 必须未定义返回值;

2. 必须定义且只能定义两个参数,第一个参数的数据类型必须为属性写方法所处类本身,第二个参数的数据类型不能为数组,该数据类型即为本属性被写入时所需要的数据类型.

如果属性写方法不为静态方法,所要求的定义格式:

1. 必须未定义返回值;

2. 必须定义且只能定义一个参数,该参数的数据类型不能为数组,该数据类型即为本属性被写入时所需要的数据类型.

注意:

1. 在程序中,必须以与变量相同的引用方式来访问属性写方法. 如: `类对象1.属性1 = 1`;

2. 如果存在同名属性读方法,则两者的数据类型必须一致;

例程:
```volcano
<火山程序 类型 = "通常" 版本 = 1 />

包 火山.例程

类 启动类 <公开 基础类 = 程序类>
{
    方法 启动方法 <公开 类型 = 整数>
    {
        变量 变量1 <类型 = 类1 注释 = "定义\"类1\"的实例变量,并同时在其成员属性表中指定\"属性2\"的值." 属性2 = 2>
        标准输出行 (, 到文本 (变量1.属性1) + ", " + 到文本 (变量1.属性2))  // 输出所设置的属性值. "属性1"在"类1"自身的成员属性表中被设置,"属性2"在定义"变量1"时被设置.
        变量1.属性1 = 3  // 属性必须以与变量相同的方式访问
        变量1.属性2 = 4
        标准输出行 (, 到文本 (变量1.属性1) + ", " + 到文本 (变量1.属性2))
        返回 (1)
    }
}

类 类1 <注释 = "在类自身的成员属性表中可以使用自身定义的属性,该属性将在创建类对象实例时被自动设置." 属性1 = 1>
{
    变量 变量1 <类型 = 整数 注释 = "用作存储\"属性1\"数据">
    变量 变量2 <类型 = 整数 注释 = "用作存储\"属性2\"数据">

    方法 属性1 <公开 静态 属性读 类型 = 整数 注释 = "以静态方法的方式定义属性读方法">
    参数 对象自身 <类型 = 类1 注释 = "此时其第一个参数必须为当前类自身">
    {
        返回 (对象自身.变量1)
    }

    方法 属性1 <公开 静态 属性写 注释 = "以静态方法的方式定义属性写方法">
    参数 对象自身 <类型 = 类1 注释 = "此时其第一个参数必须为当前类自身">
    参数 参数1 <类型 = 整数>
    {
        对象自身.变量1 = 参数1
    }

    方法 属性2 <公开 属性读 类型 = 整数 注释 = "以非静态方法的方式定义属性读方法">
    {
        返回 (变量2)
    }

    方法 属性2 <公开 属性写 注释 = "以非静态方法的方式定义属性写方法">
    参数 参数1 <类型 = 整数>
    {
        变量2 = 参数1
    }
}
```

运行输出结果:
```
1, 2
3, 4
```

### 事件

事件用作支持在类中发送和接收通知.

#### 定义事件

类的事件通过定义类别为"定义事件"的方法来声明,该方法提供了事件的名称及格式,且必须满足以下要求:

- 方法体必须为空;

- 返回值数据类型必须为整数;

- 不能为静态方法.

所声明事件的名称为该事件定义方法的名称,通过直接调用该方法即可触发此事件.

#### 接收事件

类可以接收来自以下两个来源的事件:

1. 本类对象自身;

2. 本类中定义的所有数据类型为类的成员变量.

这两种对象的类数据类型(包括其直接/间接基础类)称为**事件对象类**,该类中所有类别为"定义事件"的方法声明了其可能会触发的事件.

接收这些事件需要通过定义类别为"接收事件"的方法,该方法必须满足以下要求:

1. 返回值数据类型必须为整数;

2. 不能为静态方法;

3. 方法名称格式必须为: 事件对象类名 + 下划线字符 + 欲接收事件名;

4. 方法的第1个参数的数据类型必须为欲接收其事件的事件对象类名;

5. 方法的第2个参数的数据类型必须为整数,用作接收"挂接事件"关键字调用所提供的"标记值"参数值(非该方式挂接事件则此参数值固定为0);

6. 方法其余参数的数目及数据类型必须与欲接收事件的"定义事件"方法一致.

例程:
```volcano
<火山程序 类型 = "通常" 版本 = 1 />

包 火山.例程

类 启动类 <公开 基础类 = 程序类>
{
    变量 成员变量1 <类型 = 类2 注释 = "变量数据类型\"类2\"及其基础类\"类1\"中定义的事件,均可以在本类中接收.">
    变量 成员变量2 <类型 = 类2 注释 = "定义两个成员变量,用作在下面演示如何区分事件来源对象.">

    方法 启动方法 <公开 类型 = 整数>
    {
        成员变量1.触发事件1 (1)  // 手动触发"类1"中定义的事件1". 在系统类库中,事件往往是在封装代码中触发的,此处只是用作演示.
        成员变量1.触发事件2 (2, "来自\"成员变量1\"")  // 手动触发"类2"中定义的事件2"
        成员变量2.触发事件2 (3, "来自\"成员变量2\"")  // 同上
        返回 (1)
    }

    方法 类2_事件2 <接收事件 类型 = 整数 注释 = "接收\"类2\"对象中发送过来\"事件2\". 事件接收方法名的格式必须是: \"事件对象类名 + 下划线字符 + 事件名\"." 返回值注释 = "事件接收方法的返回值必须为整数,哪怕没有使用.">
    参数 来源对象 <类型 = 类2 注释 = "提供事件产生的具体来源对象">
    参数 标记值 <类型 = 整数 注释 = "用户调用\"挂接事件\"命令时所提供的\"标记值\"参数值,非此方式挂接事件则本参数值固定为0.">
    参数 事件参数1 <类型 = 整数>
    参数 事件参数2 <类型 = 文本型>
    {
        如果 (来源对象 == 成员变量1)  // 由于"成员变量1"和"成员变量2"的"类2.事件2"都在此处处理,所以需要判断事件来源对象以进行分别处理.
        {
            标准输出行 (, "接收到来自\"成员变量1\"对象的类型\"类2\"的\"事件2\",参数值为: " + 到文本 (事件参数1) + ", " + 事件参数2)
        }
        否则 (来源对象 == 成员变量2)  // 判断事件来源对象是否为"成员变量2"
        {
            标准输出行 (, "接收到来自\"成员变量2\"对象的类型\"类2\"的\"事件2\",参数值为: " + 到文本 (事件参数1) + ", " + 事件参数2)
        }
        返回 (0)
    }
}

类 类1
{
    方法 事件1 <公开 定义事件 类型 = 整数 注释 = "定义一个事件">
    参数 事件参数1 <类型 = 整数>

    方法 触发事件1 <公开 类型 = 整数 注释 = "用作触发所声明的\"事件1\"." 注释 = "在系统类库中,事件往往是在封装代码中触发的,此处只是用作演示.">
    参数 事件参数1 <类型 = 整数>
    {
        返回 (事件1 (事件参数1))
    }
}

类 类2 <基础类 = 类1 注释 = "定义一个\"类1\"的继承类">
{
    方法 事件2 <公开 定义事件 类型 = 整数 注释 = "定义一个事件">
    参数 事件参数1 <类型 = 整数>
    参数 事件参数2 <类型 = 文本型>

    方法 触发事件2 <公开 类型 = 整数 注释 = "用作触发所声明的\"事件2\"">
    参数 事件参数1 <类型 = 整数>
    参数 事件参数2 <类型 = 文本型>
    {
        返回 (事件2 (事件参数1, 事件参数2))
    }

    方法 类1_事件1 <接收事件 类型 = 整数 注释 = "用作接收本类自身在基础类\"类1\"中定义的\"事件1\"."
            注释 = "注意事件接收方法的名称必须为: 事件类名 + \"_\" + 事件名称">
    参数 来源对象 <类型 = 类1>
    参数 标记值 <类型 = 整数>
    参数 事件参数1 <类型 = 整数>
    {
        标准输出行 (, "接收到来自\"类1\"的\"事件1\",参数值为: " + 到文本 (事件参数1))
        返回 (0)
    }
}
```

运行输出结果:
```
接收到来自"类1"的"事件1",参数值为: 1
接收到来自"成员变量1"对象的类型"类2"的"事件2",参数值为: 2, 来自"成员变量1"
接收到来自"成员变量2"对象的类型"类2"的"事件2",参数值为: 3, 来自"成员变量2"
```

#### 动态挂接事件

以本类对象自身和本类中成员变量为来源的事件,只要在本类中定义了相应的事件接收方法即可自动挂接并接收处理. 来自其它来源对象的事件并不会被自动挂接接收,譬如对象数组成员,静态成员变量等,在这种情况下就需要动态挂接处理事件.

动态挂接处理事件需要使用"挂接事件"和"取消事件挂接"系统关键字,并同时定义对应的事件接收方法.

例程:
```volcano
<火山程序 类型 = "通常" 版本 = 1 />

包 火山.例程

类 启动类 <公开 基础类 = 程序类>
{
    变量 成员变量数组1 <类型 = "类1 [2]" 注释 = "以数组成员对象为来源的事件不会被自动挂接">
    变量 静态成员变量1 <静态 类型 = 类1 注释 = "以静态成员变量对象为来源的事件不会被自动挂接">

    方法 启动方法 <公开 类型 = 整数>
    {
        标准输出行 (, "事件尚未被挂接")
        // 手动触发"类1"中定义的事件1". 此时由于事件尚未被挂接,因此此时无法接收到事件.
        成员变量数组1 [0].触发事件1 (1)
        静态成员变量1.触发事件1 (2)

        挂接事件 (成员变量数组1 [0], 123)  // 挂接事件并设置标记值为123
        挂接事件 (静态成员变量1, 234)

        标准输出行 (, "事件已经被挂接")
        // 再次触发"类1"中定义的事件1". 此时由于事件已经被挂接,因此可以正常接收并处理事件.
        成员变量数组1 [0].触发事件1 (1)
        静态成员变量1.触发事件1 (2)

        返回 (1)
    }

    方法 类1_事件1 <接收事件 类型 = 整数 注释 = "定义一个事件">
    参数 来源对象 <类型 = 类1 注释 = "提供事件产生的具体来源对象">
    参数 标记值 <类型 = 整数 注释 = "用户调用\"挂接事件\"命令时所提供的\"标记值\"参数值,非此方式挂接事件则本参数值固定为0.">
    参数 事件参数1 <类型 = 整数>
    {
        标准输出行 (, "接收到\"类1\"的\"事件1\",参数值为: " + 到文本 (事件参数1) + ", 事件标记值为: " + 到文本 (标记值))
        返回 (0)
    }
}

类 类1
{
    方法 事件1 <公开 定义事件 类型 = 整数 注释 = "定义一个事件">
    参数 事件参数1 <类型 = 整数>

    方法 触发事件1 <公开 类型 = 整数 注释 = "用作触发所声明的\"事件1\"." 注释 = "在系统类库中,事件往往是在封装代码中触发的,此处只是用作演示.">
    参数 事件参数1 <类型 = 整数>
    {
        返回 (事件1 (事件参数1))
    }
}
```

运行输出结果:
```
事件尚未被挂接
事件已经被挂接
接收到"类1"的"事件1",参数值为: 1, 事件标记值为: 123
接收到"类1"的"事件1",参数值为: 2, 事件标记值为: 234
```

### 方法语句行

方法语句行的语法格式: 

	方法语句行 = [成员属性表] (赋值表达式 | 调用表达式)

	表达式 = 一元表达式 | 表达式 二元操作符 表达式

	一元表达式 = 基本表达式 | 一元操作符 一元表达式

	基本表达式 = 操作数 | 类型强转表达式 | 对象成员访问表达式 | 数组成员访问表达式 | 调用表达式

	操作数 = 立即数 | 名称 | "(" 表达式 ")"

	赋值表达式 = (变量名称 | 参数名称 | 对象成员访问表达式 | 数组成员访问表达式) "=" 表达式

	类型强转表达式 = "(" 类型名称 ")" 一元表达式

	对象成员访问表达式 = 类成员名称 | 类访问名称 "." 类成员名称 | 基本表达式 "." 类成员名称 | "父对象" "." 父类成员名称 | 本对象

	数组成员访问表达式 = 基本表达式 "[" 表达式 "]" { "[" 表达式 "]" }

	调用表达式 = 对象成员访问表达式 调用参数表 | 命令关键字名称 调用参数表

	一元操作符 = "-"

	二元操作符 = "&&" | "||" | "==" | "!=" | "<" | "<=" | ">" | ">=" | "属于" | "*" | "/" | "%" | "+" | "-"

	调用参数表 = "(" [ 表达式 { "," 表达式 } ] ")"

	类型名称 = 基本类型名称 | 类访问名称

	基本类型名称 = 字节 | 短整数 | 字符 | 整数 | 变整数 | 长整数 | 单精度小数 | 小数 | 逻辑型 | 文本型

	类访问名称 = 类名称 | 类所处包名 "." 类名称

方法语句行必须位于方法或另一语句行的子语句体中,可以在其下一行紧跟一个附属子语句体,子语句体由使用花括号括住的一系列语句行组成.

注意,在以下几种情况下,无论该语句行是否具有属性,都必须在首部添加一个空的成员属性表(即"<>"):

1. 语句行内容以 '<' 字符开头;

2. 语句行内容以以下单词开头: 包, package, 类, class, 方法, method, 参数, param, 常量, const, 变量, var ;

3. 语句行内容为单个的 '{' 或 '}' 字符.

如: 语句行 "包 = 1" 必须以 "<> 包 = 1" 表达, 语句行 "<123" 必须以 "<> <123" 表达.

语句行样例:

	变量1 = -变量2 + 123  // 赋值表达式, 表达式, 一元操作符

	对象变量1.方法1 (1, 2).方法2 ()  // 对象成员访问表达式, 调用表达式

	短整数变量1 = (短整数)整数变量1  // 类型强转表达式

	数组变量1 [变量1][1].方法1 (数组变量2 [0])  // 数组成员访问表达式

	// 带子语句块的语句行
	如果 (变量1 == 1 || 变量2 == 3)  // 二元操作符
	{  // 注意: 子语句块的左花括号必须位于单独一行,不能放到所属语句行的尾部.
		......
	}  // 注意: 子语句块的右花括号也必须位于单独一行

### 注释

可以使用以下方式在火山程序中添加注释:

1. 任何定义型成员(包/类/方法/变量/常量/参数)其名称如果以"//"字符串引导,说明其处于被注释状态,其以及其中的所有内容(包括直接/间接子成员)在编译时都将被忽略. 如果是包定义成员,整个源文件都将被忽略;

2. 成员属性表中的属性名称如果以"//"字符串引导,表明该属性被注释;

3. 在方法语句行中,可以使用"//"字符串引导一段一直到行尾的注释文本.

4. 不为方法语句行且以'#'字符开始的行,为文档或类注释行. 其语法格式为:
	
	"#" [成员属性表] 注释行内容 | "//" 注释行内容
	
	注意: 采用 '#' 字符引导格式的文档或类注释行如果以 '<' 字符开头,则无论该行是否具有属性,都必须在内容前方添加一个空的成员属性表. 如: "# <注释1" 就必须使用 "# <> <注释1" 来表达.

文档注释行/类注释行/从语句行首开始的方法语句注释文本,这三类注释其尾部如果以一个或多个减号/等号字符结束,IDE将自动在其后绘制对应长度的单/双分隔线.

例程:
```volcano
<火山程序 类型 = "通常" 版本 = 1 />

包 "// 火山.例程" <注释 = "包名以\"//\"字符串开头,表明当前整个源文件均被注释掉了.">

// 位于类外部的非成员定义行,称为文档注释行.

// 下面为一个具有两个标准长度的单分隔线

// --

类 "// 启动类" <公开 基础类 = 程序类 注释 = "类名以\"//\"字符串开头,表明该类的所有内容均被注释掉了."
        注释 = "成员属性表中的\"属性1\"以\"//\"字符串开头,表明该属性被注释掉了." "// 属性1" = 123>
{
    // 位于类里面的非成员定义行,称为类注释行.

    方法 "// 启动方法" <公开 类型 = 整数 注释 = "方法的名称以\"//\"字符串开头,表示整个方法被注释掉了.">
    {
		// 下面为一个具有两个标准长度的双分隔线
		// ==

        返回 (1)  // 语句行注释: 从"//"字符串开始到语句行尾部均被注释
    }
}
```

### 程序结构示例

下面是一个完整具有各种成员的火山源程序示例:
```volcano
<火山程序 类型 = "通常" 版本 = 1 />

包 火山.例程 <注释 = "包定义成员">

// 文档注释行

类 类1 <公开 基础类 = 程序类 注释 = "类定义成员和其成员属性表" 标记值 = 123>
{
    // 类注释行

    变量 成员变量1 <类型 = 整数 注释 = "类成员变量定义">

    常量 成员常量1 <类型 = 整数 值 = 123 注释 = "类成员常量定义">

    方法 方法1 <公开 类型 = 整数 注释 = "方法定义成员">
	参数 参数1 <类型 = 整数 注释 = "方法参数定义成员">
	参数 参数2 <类型 = 整数>
    {
        变量 局部变量1 <类型 = 整数 注释 = "局部变量定义">
        常量 局部常量1 <类型 = 整数 值 = 123 注释 = "局部常量定义">

        返回 (成员变量1 + 成员常量1 + 局部变量1 + 局部常量1)  // 方法语句行及行尾注释文本
    }
}
```

## 系统关键字

### 基本数据类型

| 名称 | 解释 |
|:----|:----|
| 字节 | 字节(有符号)基本数据类型,有效值范围从-128到127,占用1个字节空间. |
| 短整数 | 短整数基本数据类型,有效值范围从-32768到32767,占用2个字节空间. |
| 字符 | 宽字符基本数据类型,有效值范围从0到65535,占用2个字节空间. |
| 整数 | 整数基本数据类型,有效值范围从-2147483648到2147483647,占用4个字节空间. |
| 变整数 | 变整数基本数据类型,在编译64位视窗子平台程序时等同于长整数类型,编译32位视窗子平台程序时等同于整数类型,在其它情况下均等同于整数类型. 由于变整数的数据尺寸等于当前目的cpu的位数,因此常用作表达c/c++目的程序里面的指针值. |
| 长整数 | 长整数基本数据类型,有效值范围从-9223372036854774808到9223372036854774807,占用8个字节空间. |
| 单精度小数 | 单精度小数基本数据类型,有效值范围从-3.40E+38到3.40E+38,占用4个字节空间. |
| 小数 | 双精度小数基本数据类型,有效值范围从-1.7E+308到1.7E+308,占用8个字节空间. |
| 逻辑型 | 逻辑型基本数据类型,有效值为真/假. |
| 文本型 | 文本型基本数据类型,用作记录一段[字符串](#字符串)文本. |
| 模板类型1 -> 模板类型8 | 模板数据类型. 只能在模板基础类中使用,其所对应的真实数据类型需要由模板实现类来提供. |

例程:
```volcano
<火山程序 类型 = "通常" 版本 = 1 />

常量 常量1 <类型 = 字节 值 = 127>
常量 常量2 <类型 = 短整数 值 = 32767>
常量 常量3 <类型 = 字符 值 = '\n'>
常量 常量4 <类型 = 整数 值 = 1>
常量 常量5 <类型 = 变整数 值 = 2>
常量 常量6 <类型 = 长整数 值 = 3>
常量 常量7 <类型 = 单精度小数 值 = 1.23>
常量 常量8 <类型 = 小数 值 = 3.1415926>
常量 常量9 <类型 = 逻辑型 值 = 真>
常量 常量10 <类型 = 文本型 值 = "你好\n世界">
```

#### 整数类型

整数类型包括: 字节, 短整数, 字符, 整数, 变整数, 长整数.

#### 数值类型

数值类型包括: 整数类型, 单精度小数, 小数.

各种数值类型的容量从小到大排列: 字节 < 短整数 < 字符 < 整数 < 长整数 < 单精度小数 < 小数

数值计算表达式的最终数据类型确定方法: 为数值计算表达式中具有最大容量的数值数据类型

### 名称关键字

| 名称 | 解释 |
|:----|:----|
| 本对象 | 用作在类成员方法中代表所处类的对象本身 |
| 父对象 | 用作在类成员方法中代表所处类的父对象,注意本关键字只能在句点操作符的第一个参数位置处使用. |
| 真 | 用作代表逻辑值真 |
| 假 | 用作代表逻辑值假 |
| 空对象 | 用作代表空对象,可以匹配所有非常量类的类数据类型以及文本型. |

下面代码演示了各种名称关键字的使用方法:
```volcano
<火山程序 类型 = "通常" 版本 = 1 />

包 火山.例程

类 启动类 <公开 基础类 = 程序类>
{
    方法 启动方法 <公开 类型 = 整数>
    {
        变量 变量1 <类型 = 继承类1>
        变量1.方法2 ()  // 调用"继承类1"对象的"方法2"
        方法1 (空对象)  // 调用"方法1",传递过去一个空对象.
        返回 (1)
    }

    方法 方法1
    参数 参数1 <类型 = 继承类1 注释 = "空对象也可以用作类对象参数的\"@默认值\"属性值" @默认值 = 空对象>
    {
        如果 (参数1 == 空对象)  // 检查所传递过来的参数值是否为空对象
        {
            标准输出行 (, "接收到空对象")
        }
    }
}

类 基础类1
{
    方法 方法1 <注释 = "定义一个基础类的\"方法1\"虚拟方法" @虚拟方法 = 可覆盖>
    {
        标准输出行 (, "\"基础类1\"的\"方法1\"被调用")
    }
}

类 继承类1 <基础类 = 基础类1>
{
    方法 方法1 <注释 = "覆盖了\"基础类1\"中定义的\"方法1\"虚拟方法" @虚拟方法 = 可覆盖>
    {
        父对象.方法1 ()  // 如果不使用"父对象"指定,将会调用本类对象的"方法1",通过使用"父对象"指定,可以强制指定调用本类的基础类"基础类1"的"方法1".
        标准输出行 (, "\"继承类1\"的\"方法1\"被调用")
    }

    方法 方法2 <公开>
    {
        本对象.方法1 ()  // 演示"本对象"的使用方法,实际上由于默认会使用"本对象",此处的"本对象"指定是多余的,仅用作演示.
    }
}
```

运行输出结果:
```
"基础类1"的"方法1"被调用
"继承类1"的"方法1"被调用
接收到空对象
```

### 操作符关键字

| 名称 | 特性 | 优先级 | 首/左侧参数 | 右侧参数 | 解释 |
|:----|:-----|:------|:------------|:--------|:-----|
| . | [可扩展] | 1 | 欲访问类/类对象名称 | 欲访问类成员名称 | 句点分隔操作符,用作分隔类/类对象与其成员名称. <br> 如,访问类的动态成员变量: `类对象1.成员变量1`; 访问类的静态成员方法: `类1.成员方法1 ()` |
| [] | [只能为参数] [可扩展] | 1 | 欲访问数组数据 | [整数] 欲访问数组成员索引值 | 数组成员访问操作符,用作访问所指定索引位置处的数组成员. <br> 数组成员访问索引值从0开始,有效范围为从0到数组成员数-1,分别对应数组的第一个和最后一个成员. <br> 如,访问单维数组成员: `数组变量 [0]`; 访问多维数组成员: `数组变量 [1][2]` |
| - | [只能为参数] [右结合] | 2 | [数值] 欲取反的数值 | | 算术取反操作符,用作返回将指定数值进行符号翻转后的结果值. 如: `-123`, `-变量1`. |
| 强制类型转换 | [只能为参数] [右结合] | 2 | 欲转换到数据类型名称 | 欲转换数据类型的数据 | 类型强转操作符,用作将数据转换到所指定的数据类型. <br> 调用格式为: (欲强行转换到的数据类型)欲转换类型的数据 <br> 允许以下数据类型之间进行强制转换: <br> 1. "空对象"可以强制转换到任何非常量类的类数据类型或文本型; <br> 2. 数值数据类型之间可以强行转换. 如: `(长整数)1`, `(短整数)整数变量1`; <br> 3. 常量类可以强制转换到其所对应的基本数据类型,非立即数基本数据类型数据可以强制转换到对应的常量类. 如: `(整数)整数常量类常量1`; <br> 4. 类数据类型只能强制转换到其直接/间接基础类或继承类. 如假设基础类对象的类为"继承类1"的基础类,可以如此转换: `(继承类1)基础类对象` |
| * | [只能为参数] [可扩展] | 3 | [数值] 被乘数 | [数值] 乘数 | 算术相乘操作符,用作计算两个数值的相乘结果. 如: `整数变量1 * 2` |
| / | [只能为参数] [可扩展] | 3 | [数值] 被除数 | [数值] 除数 | 算术相除操作符,用作计算两个数值的相除结果. 如: `整数变量1 / 2` |
| % | [只能为参数] | 3 | 同"/" | 同"/" | 算术模除操作符,用作计算两个整数的相除后的余数. 如: `整数变量1 % 2` |
| + | [只能为参数] [可扩展] | 4 | [数值/文本] 被加数 | [数值/文本] 加数 | 相加操作符,用作计算两个数值/文本的相加结果. 如: `整数变量1 + 2`, `文本变量1 + "abc"`. |
| - | [只能为参数] [可扩展] | 4 | [数值] 被减数	[数值] | 减数 | 算术相减操作符,用作计算两个数值的相减结果. 如: `整数变量1 - 2` |
| <= | [只能为参数] | 5 | [数值] 被比较数值 | [数值] 比较数值 | 小于等于逻辑比较操作符,当左侧参数小于等于右侧参数时返回真. 如: `整数变量1 <= 2` |
| >= | [只能为参数] | 5 | 同"<=" | 同"<=" | 大于等于逻辑比较操作符,当左侧参数大于等于右侧参数时返回真. 如: `整数变量1 >= 2` |
| < | [只能为参数] | 5 | 同"<=" | 同"<=" | 小于逻辑比较操作符,当左侧参数小于右侧参数时返回真. 如: `整数变量1 < 2` |
| > | [只能为参数] | 5 | 同"<=" | 同"<=" | 大于逻辑比较操作符,当左侧参数大于等于右侧参数时返回真. 如: `整数变量1 > 2` |
| 属于 | [只能为参数] | 5 | [对象] 被检查对象 | 用作检查的类名 | 返回左侧对象是否为右侧类或者其直接/间接继承类的实例对象,即左侧对象能否被安全转换到右侧类数据类型. <br> 注意: 左侧对象的数据类型必须为类,而且必须与右侧类之间存在继承/被继承关系或者等于右侧类. <br> 如,检查"对象1"的类型是否为"类1": `对象1 属于 类1` |
| == | [只能为参数] | 6 | [数值/逻辑型/文本/数组/对象] 被比较值 | [数值/逻辑型/文本/数组/对象]  比较值 | 等于/不等于逻辑比较操作符,当左侧参数等于/不等于右侧参数时返回真. 注意: <br> 1. 对于数组对象,唯一能够与其进行比较的是"空对象". 如: `数组变量1 == 空对象`; <br> 2. 对于文本数据,将比较两者实际文本内容是否相同(区分字母大小写),也可以将文本数据与"空对象"进行比较. 如: `文本变量1 == "abc"`; <br> 3. 类对象比较仅比较两者是否指向同一个对象实例(即比较两个对象的所处地址是否相同),而不会去对比两者所指向对象实例中存放的数据内容是否相同. 如: `对象变量1 == 对象变量2`, `对象变量1 == 空对象`; <br> 4. 如欲比较两个对象的数据内容是否相同,可以使用系统类库中所提供的"对象内容是否相同"全局方法. 如: `对象内容是否相同 (对象变量1, 对象变量2)`; <br> 5. "字节集类"是一个特例,该类的对象之间进行比较将比较两者的实际数据内容是否相同. |
| != | [只能为参数] | 6  | 同"==" | 同"==" | 同"==" |
| && | [只能为参数] [可扩展] | 7 | [逻辑型] 逻辑值一 | [逻辑型] 逻辑值二 | 并且逻辑操作符,当左侧参数和右侧参数均为逻辑值真时返回真. 如: `整数变量1 >= 1 && 整数变量1 <= 10` |
| \|\| | [只能为参数] | 8 |  同"&&" | 同"&&" | 或者逻辑操作符,当左侧参数和右侧参数其中任意一个为逻辑值真时返回真. 如: `整数变量1 < 1 || 整数变量1 > 10` |
| =	| [右结合] | 9 | 赋值到的变量/可写属性 | 用作提供赋值用数据 | 赋值操作符,将右侧参数的值赋予给左侧参数所指定的变量/可写属性. 如: `整数变量1 = 123` |

表格说明:

1. 表格中的优先级值越小表明该操作符优先级越高;

2. "特性"列中的"[只能为参数]"表示该操作符只能位于方法语句参数中; "[右结合]"表示操作符参数为右结合; "[可扩展]"表明其右侧参数可以被扩展多个.

3. "首/左侧参数"/"右侧参数"列中用中括号括住的文本提供该参数所需求的数据类型;

### 命令关键字

命令关键字的调用方法和方法一致,为命令关键字名称后跟随一个小括号括住的调用参数表.

| 名称 | 特性 | 参数表 | 返回值 | 解释 |
|:----|:-----|:-------|:------|:----|
| 判断循环 | [需求语句体] | **参数1**: 逻辑型 判断值. 当此参数值为真时进入循环体,为假时将跳过循环体. | | 本命令根据提供的逻辑参数的值,来决定是否进入循环体.如果提供的逻辑参数值为真,程序顺序执行下一条语句进入循环体,否则跳转到本命令循环体的下一条语句处. |
| 循环 | [需求语句体] <br> [隐藏空参数表] | **参数1**: 整数 变量起始值 [可省略]. 定义循环变量的起始数值,如果被省略,默认值为0. <br> **参数2**: 整数 变量目标值 [可省略]. 定义循环变量的目标数值,在循环首部如果发现循环变量值已到达此目标值时(递增值小于0时小于等于目标值,递增值大于0时大于等于目标值)将跳出循环而不再进入循环体. 如果被省略,默认值为1. <br> **参数3**: 整数 循环变量 [可省略] [需求可写变量]. 本整数型变量将用作控制循环执行次数,在循环尾部将自动递增或递减该变量内的数值(由变量递增值参数决定).循环体中的用户程序可以直接取用此变量中的值. 如果被省略,将自动使用内部临时变量. <br> **参数4**: 整数 变量递增值 [可省略] [需求立即数]. 每次执行到循环尾部时都将把此值加入到循环变量中去,此值可为正数或负数,如为正数则递增,为负数则递减. 注意: 必须为本参数提供非0整数立即值,以便编译器建立循环结束条件. 如果被省略,则默认值为1. | | 本命令将利用变量对循环体内的命令进行循环执行.第一次执行此命令时将使用"变量起始值"参数初始化"循环变量"参数所指定的变量.每次(包括第一次)执行到此命令处都将判断循环变量内的值是否已经到达"变量目标值"参数所指定的值,如已等于或超过,则跳转到循环体的下一条语句处,否则进入循环体. |
| 如果 | [需求语句体] | **参数1**: 逻辑型 判断条件. 本条件值的结果决定下一步程序执行位置 | | 本命令根据所提供逻辑参数的值,来决定是否改变程序的执行位置.如果提供的逻辑参数值为真,程序继续顺序向下执行进入本命令的子语句体,然后跳过本命令后续所有的"否则"命令,为假则将跳过本命令的子语句体. |
| 否则 | [需求语句体] <br> [隐藏空参数表] | **参数1**: 逻辑型 判断条件. 本条件值的结果决定下一步程序执行位置. 注意: 本参数可忽略以不提供,但是此时不能再后续跟随其它的"否则"语句. | | 本命令只能放在"如果"或其它"否则"命令的后面,根据所提供逻辑参数的值,来决定是否改变程序的执行位置.如果提供的逻辑参数值为真,程序继续顺序向下执行进入本命令的子语句体,然后跳过本命令后续所有的"否则"命令,为假则将跳过本命令的子语句体. |
| 到循环尾 | [隐藏空参数表] | | | 本命令转移当前程序执行位置到当前所处循环体的尾部 |
| 跳出循环 | [隐藏空参数表]	| | | 本命令转移当前程序执行位置到当前所处循环体尾部的下一条语句处 |
| 返回 | [隐藏空参数表] | **参数1**: 返回值 [可省略]. 当所处方法定义有非空返回值数据类型时,必须提供返回到调用方的具体值,否则必须省略掉本参数,即两者必须对应. | | 本命令转移当前程序执行位置到调用本语句所处方法的下一条语句处,并可根据需要返回一个值到调用语句处. |
| 取反 | | **参数1**: 逻辑型 待取反逻辑值. 提供将其反转的逻辑值 | 逻辑型 | 将所指定逻辑值进行反转,返回反转后的结果. 如: `取反 (逻辑值1)` |
| 位取反 | | **参数1**: [整数类型](#整数类型) 待取反整数值. 提供将其所有位反转的整数值 | 对应[整数类型](#整数类型) | 将所指定整数值的每一位进行反转,返回反转后的结果. 如: `位取反 (1)` |
| 位与 | | **参数1**: [整数类型](#整数类型) 整数参数一. 提供用作位操作的整数参数值一	<br> **参数2**: [整数类型](#整数类型) 整数参数二. 提供用作位操作的整数参数值二 | 对应[整数类型](#整数类型) | 将参数1的每一位与参数2的对应位进行与操作,返回运算后的结果. 如: `位与 (0xFF, 整数变量1)` |
| 位或 | | 同"位与"	| 同"位与" | 将参数1的每一位与参数2的对应位进行或操作,返回运算后的结果. 如: `位或 (整数变量1, 1)` |
| 位异或 | | 同"位与"	| 同"位与" | 将参数1的每一位与参数2的对应位进行异或操作,返回运算后的结果. 如: `位异或 (整数变量1, 1)` |
| 位左移 | | **参数1**: [整数类型](#整数类型) 待位移整数值. 提供被位移的整数值 <br> **参数2**: [整数类型](#整数类型) 位移数目. 提供进行位移的位数 | 对应[整数类型](#整数类型) | 将参数1的每一位向左无符号移动参数2所指定的数目,返回运算后的结果. 如: `位左移 (整数变量1, 1)` |
| 位右移 | | 同"位左移" | 同"位左移" | 将参数1的每一位向右无符号移动参数2所指定的数目,返回运算后的结果. 如: `位右移 (整数变量1, 1)` |
| 编译出错 | | | | 仅在编译程序时起作用,用作告知编译器发现了编译错误并停止编译. |
| 调试检查 | | **参数1**: 逻辑型 检查值. 在调试版中,当此参数值为假时,程序将中断执行并报错. <br> **参数2**: 文本型 检查失败信息 [可省略]. 指定当检查失败时(检查值参数为假)所输出的信息.如果被省略,则默认为空文本. | | 本命令的调用语句仅在程序所编译的调试版本中存在,在程序所编译的发布版中将被忽略不编译. 在调试版中,当所提供的参数值为假时,程序将在此处中断执行并报错. 如: `调试检查 (参数1 == 1, "无效的参数值")` |
| 为调试版 | | | 逻辑型 | 返回当前所编译程序是否为调试版本 |
| 挂接事件 | | **参数1**: 对象型 欲挂接其事件的对象. 提供欲将其所定义事件挂接到当前类对应事件接收方法的对象. <br> **参数2**: 整数 标记值 [可省略]. 用作提供欲挂接其事件的对象所对应的标记值,由用户自行定义.该值将被原值发送给事件接收方法,用作区分具体的事件来源.如果被省略,则默认为0. | | 将指定对象所支持的事件挂接到当前类对象中的对应事件接收方法上. 本命令仅用作动态挂接对象事件,类及类中定义的成员对象变量除非明确指定不自动挂接,均会自动挂接事件. 参见[动态挂接事件](#动态挂接事件). |
| 取消事件挂接 | | **参数1**: 对象型 欲取消其事件挂接的对象. 提供欲取消将其所定义事件挂接到当前类对应事件接收方法的对象 | | 不再将指定对象所支持的事件挂接到当前类对象中的对应事件接收方法上. 无论是自动挂接事件还是手动调用挂接事件关键字挂接的对象,均可以调用本关键字取消其事件挂接. 事件挂接一旦取消,该对象的事件将不会再被接收到. 参见[动态挂接事件](#动态挂接事件). |

表格说明:

1. "特性"列中的"[需求语句体]"表示该命令需要携带一个子语句体,"[隐藏空参数表]"表示当该命令的参数表为空时将被省略掉不显示;

2. "参数表"列中的"[可省略]"表示该参数可以被省略不提供; "[需求可写变量]"表示必须为该参数提供一个可写入变量或参数; "[需求立即数]"表示必须为该参数提供一个立即数.

**循环类关键字例程**:
```volcano
<火山程序 类型 = "通常" 版本 = 1 />

包 火山.例程

类 启动类 <公开 基础类 = 程序类>
{
    方法 启动方法 <公开 类型 = 整数>
    {
        变量 变量1 <类型 = 整数>
        判断循环 (变量1 < 2)  // 演示如何使用"判断循环"
        {
            标准输出行 (, "1. 循环: " + 到文本 (变量1))
            变量1 = 变量1 + 1
        }
        循环  // 由于"循环"命令的"变量起始值"参数默认为0,"变量目标值"默认为1,"循环变量"默认为空,"变量递增值"默认为1,因此本方法等效于: 循环 (0, 1, , 1) ,也就是说仅循环一次.
        {
            标准输出行 (, "2. 循环")
        }
        循环 (0, 2)  // 循环2次
        {
            标准输出行 (, "3. 循环")
        }
        循环 (0, 2, 变量1)  // 循环2次并输出循环值
        {
            标准输出行 (, "4. 循环: " + 到文本 (变量1))
        }
        循环 (2, 0, 变量1, -1)  // 通过指定等于-1的递增值来进行逆向循环
        {
            标准输出行 (, "5. 逆向循环: " + 到文本 (变量1))
        }
        返回 (0)
    }
}
```

运行输出结果:
```
1. 循环: 0
1. 循环: 1
2. 循环
3. 循环
3. 循环
4. 循环: 0
4. 循环: 1
5. 逆向循环: 2
5. 逆向循环: 1
```

**流程控制类关键字例程**:
```volcano
<火山程序 类型 = "通常" 版本 = 1 />

包 火山.例程

类 启动类 <公开 基础类 = 程序类>
{
    方法 启动方法 <公开 类型 = 整数>
    {
        变量 变量1 <类型 = 整数>
        循环 (0, 10, 变量1)
        {
            如果 (变量1 >= 5)
            {
                跳出循环  // 提前跳出循环
            }
            否则 (变量1 == 2)
            {
                到循环尾  // 跳过不输出循环值 2
            }
            方法1 (变量1)
        }
        返回 (0)  // 返回调用方
    }

    方法 方法1
    参数 参数1 <类型 = 整数>
    {
        如果 (参数1 > 3)
        {
            标准输出行 (, "参数值 " + 到文本 (参数1) + " 大于3")
        }
        否则 (参数1 > 1)
        {
            标准输出行 (, "参数值 " + 到文本 (参数1) + " 大于1")
        }
        否则
        {
            标准输出行 (, "参数值 " + 到文本 (参数1) + " 小于等于1")
        }
    }
}
```

运行输出结果:
```
参数值 0 小于等于1
参数值 1 小于等于1
参数值 3 大于1
参数值 4 大于3
```

## 程序类型

火山视窗程序目前分为控制台程序和窗口程序两种.

### 控制台程序

使用控制台窗口作为界面的程序称为控制台程序,控制台程序的"启动类"必须以"程序类"作为基础类.

例程:
```volcano
<火山程序 类型 = "通常" 版本 = 1 />

包 火山.例程

类 启动类 <公开 基础类 = 程序类 注释 = "控制台程序必须以\"程序类\"为基础类">
{
    方法 启动方法 <公开 类型 = 整数>
    {
        标准输出行 (, "控制台程序被执行")
        返回 (1)
    }
}
```

### 窗口程序

使用 Windows 窗口来作为界面的程序称为窗口程序,窗口程序的"启动类"必须以"窗口程序类"作为基础类.

#### 相关概念

**窗口界面类**: "窗口"类的继承类.

**窗口组件类**: 定义有"@视窗.窗口组件"属性的"窗口组件"类的继承类.

窗口程序通过创建窗口来展示界面,所有窗口通过定义窗口界面类的对象实例来创建.

#### 布局属性表

窗口布局使用布局属性表来描述其布局信息,布局属性表记录在窗口界面类或其窗口组件成员变量的"@视窗.布局"[视窗扩展属性](#视窗系统扩展属性)中.

布局属性表由单个或多个布局属性项组成,多个布局属性项之间使用换行符分隔:

布局属性表 = 布局属性项 { "\n" 布局属性项 }

布局属性项 = 布局属性名 [ "=" 布局属性值 ]

布局属性值 = [数值](#数值) | [逻辑值](#逻辑值) | [字符串](#字符串)

#### 窗口布局

窗口界面类可以通过其布局属性表来指定客户区(即不包括标题栏/边框等的剩余部分)的尺寸,相关布局属性项为:

	client_size = "宽度值, 高度值"
	
通过在窗口界面类中加入数据类型为窗口组件类的成员变量来将该类窗口组件加入当前布局,每个成员变量需要通过其布局属性表来指定在窗口中的布局信息,具有以下布局属性项:

1. id: 属性值为一个整数,用作定义该组件的ID值,在所处布局中必须唯一. 本属性必须存在且必须大于0;

2. parent_id: 属性值为一个整数,用作提供该组件的父组件的ID值.可以被省略,此时表明父组件为所处界面根布局组件;

3. pos: 属性值为一个使用双引号括住的字符串,其中存在4个使用逗号分隔的整数,分别指定该组件在其所处父组件中的左边/顶边/宽度/高度. 被省略表明均为0.

4. group: 属性值为一个整数,记录该组件的所属分组编号,必须大于0. 用作支持在程序中对组件进行分组操作.

下面例程显示了一个"你好世界"窗口,该窗口中具有一个分组框,分组框中具有一个按钮,当点击按钮后,会弹出一个信息框显示"你好,世界!":

```volcano
<火山程序 类型 = "通常" 版本 = 1 />

包 火山.示例

类 启动类 <公开 基础类 = 窗口程序类>
{
    变量 主窗口对象 <类型 = 我的主窗口类 注释 = "定义了一个\"标题\"属性值为\"你好世界\"的窗口界面类成员变量" 标题 = "你好世界">

    方法 启动方法 <公开 类型 = 整数>
    {
        主窗口对象.创建主窗口 ()  // 作为程序的主窗口创建并显示所定义窗口
        返回 (1)
    }
}

类 我的主窗口类 <基础类 = 窗口 注释 = "定义一个窗口界面类,用作建立主窗口布局."
        注释 = "通过设置其\"client_size\"布局属性来指定客户区尺寸为 300 * 200 像素." @视窗.布局 = "client_size = \"300, 200\""
        标题 = "你好世界示例">
{
    变量 分组框1 <类型 = 分组框
            注释 = "在当前窗口布局中加入一个\"分组框\"窗口组件,在其布局属性表中指定id等于101,在窗口中的坐标位置为 (34, 28), 尺寸为 (232, 144)."
            注释 = "指定\"标题\"属性为\"分组框1\"." @视窗.布局 = "id = 101\r\npos = \"34, 28, 232, 144\"" 标题 = "分组框1">
    变量 按钮_显示 <类型 = 按钮
            注释 = "在当前窗口布局中加入一个\"按钮\"窗口组件,在其布局属性表中指定id等于102,父组件ID为101(即前面定义的\"分组框1\"),在分组框中的坐标位置为 (56, 52), 尺寸为 (120, 40)."
            注释 = "指定\"标题\"属性为\"点击显示\"." @视窗.布局 = "id = 102\r\nparent_id = 101\r\npos = \"56, 52, 120, 40\""
            标题 = "点击显示">

    方法 按钮_被单击 <接收事件 类型 = 整数 注释 = "定义按钮被单击事件的事件接收方法">
    参数 来源对象 <类型 = 按钮>
    参数 标记值 <类型 = 整数>
    {
        信息框 ("你好,世界!")  // 显示信息框. 由于本类中只有一个按钮成员变量,因此不用判断事件来源是否为"按钮_显示"按钮.
        返回 (0)
    }
}
```
