
###### 以下为一个火山软件开发平台系统类库程序的内容

<火山程序 类型 = "通常" 版本 = 1 />

包 火山.无名

类 启动类 <公开 基础类 = 窗口程序类>
{
    变量 主窗口对象 <公开 类型 = 我的主窗口 注释 = "必须公开窗口，用于后续线程中组件的交互">

    方法 启动方法 <公开 类型 = 整数>
    {
        主窗口对象.创建主窗口 ()
        返回 (1)
    }
}

类 我的主窗口 <基础类 = 窗口 标题 = "线程操作组件" @视窗.布局 = "client_size = \"351, 316\"">
{
    变量 按钮2 <公开 类型 = 按钮 折叠2 隐藏值属性 = "0" @视窗.布局 = "id = 101\r\npos = \"173, 190, 96, 25\"" 标题 = "结束">
    变量 编辑框_线程数 <公开 类型 = 编辑框 注释 = "需要交互的组件，必须公开，但是不可静态，静态就不显示了" 折叠2 隐藏值属性 = "0"
            @视窗.布局 = "id = 102\r\npos = \"93, 22, 80, 24\"" 标题 = "3">
    变量 标签1 <类型 = 标签 折叠2 隐藏值属性 = "0" @视窗.布局 = "id = 103\r\npos = \"37, 22, 48, 24\"" 标题 = "线程数：">
    变量 编辑框1 <公开 类型 = 编辑框 注释 = "需要公开的组件，必须公开，但是不可静态，静态就不显示了" 隐藏值属性 = "0"
            @视窗.布局 = "id = 104\r\npos = \"37, 118, 224, 40\"">
    变量 按钮1 <公开 类型 = 按钮 隐藏值属性 = "0" @视窗.布局 = "id = 105\r\npos = \"29, 190, 96, 25\"" 标题 = "开始">
    变量 ""
    变量 "" <注释 = "" 注释 = "以下变量必须进行公开，并且选择静态，线程中才可以直接访问。" 注释 = "">
    变量 线程数 <公开 静态 类型 = 整数 注释 = "每次工作最大的线程总数。">
    变量 任务数 <公开 静态 类型 = 整数 注释 = "计划执行工作的任务总数。">
    变量 欲投递任务数 <公开 静态 类型 = 整数 注释 = "每次可以投放任务的数量，最大不超过线程数。">
    变量 运行线程数 <公开 静态 类型 = 整数 注释 = "正在执行任务的线程数量。">
    变量 已完成任务数 <公开 静态 类型 = 整数 注释 = "已完成工作的任务数量。">
    变量 许可区 <公开 静态 类型 = 互斥锁类 注释 = "使用临界资源、公共资源的时候，必须使用互斥锁，否则会冲突、崩溃。">
    变量 强制结束 <公开 静态 类型 = 逻辑型 注释 = "用于线程停止的变量">

    方法 按钮_被单击 <接收事件 类型 = 整数>
    参数 来源对象 <类型 = 按钮>
    参数 标记值 <类型 = 整数>
    {
        如果 (来源对象 == 按钮2)
        {
            强制结束 = 真
        }
        如果 (来源对象 == 按钮1)
        {
            启动线程 (多线程任务框架, 1)
        }
        返回 (0)


    }

    方法 多线程任务框架 <静态 类型 = 整数 注释 = "固定格式" 返回值注释 = "固定返回值">
    参数 用户参数 <类型 = 变整数 注释 = "固定参数">
    {
        变量 可投递任务数 <类型 = 整数>
        // 写在开头的一些小知识点
        // 与窗口组件进行交互,必须使用 取程序() 命令,同时主窗口对象必须公开,相关组件也必须公开
        // 示例: 取程序().主窗口对象.编辑框.线程数.内容

        // 临界资源:可能同时发生读写的资源称之为临界资源,必须进行互斥锁操作,否则会造成资源冲突,数据出错、崩溃等问题.


        // -----------------------多线程任务框架结构--------------------------------

        // 线程数据初始化
        强制结束 = 假
        已完成任务数 = 0  // 初始化必须将已完成任务数归0,不然你下次就无法直接执行了.

        // 获取和设置必须的数据
        取程序 ().主窗口对象.按钮1.禁止 = 真  // 将按钮组件设置为禁止状态,防止误操作!
        任务数 = 10  // 任务数可以根据你实际的情况来设置,比如与窗口组件、文本文件交互来取得任务数.
        线程数 = 文本到整数 (取程序 ().主窗口对象.编辑框_线程数.内容)


        循环判断首 ()
        {

            // 检测用户是否发送了强制结束指令
            如果真 (强制结束)
            {
                调试输出 ("接收到强制结束指令，线程即将结束！")
                跳出循环

            }


            // 计算欲投递的任务数量,用于下面的任务投递工作
            // 计算空闲的线程数量有几个,该数量不可能超过总线程数
            可投递任务数 = 线程数 - 运行线程数
            欲投递任务数 = 可投递任务数


            如果真 (欲投递任务数 > 任务数 - 已完成任务数)  // 经过一段运行之后,可能会出现欲投递的任务数,大于剩下的任务数的情况,所以要加个修正判断.
            {
                欲投递任务数 = 任务数 - 已完成任务数

            }

            // 开始进行任务投递
            计次循环 (欲投递任务数)
            {

                // 检测用户是否发送了强制结束指令
                如果真 (强制结束)
                {
                    调试输出 ("接收到强制结束指令，线程即将结束！")
                    跳出循环

                }


                如果真 (启动线程 (任务线程, 已完成任务数, , , ))
                {

                    // 线程任务投递成功,记录 运行数量和已完成的任务数.
                    // 因为运行线程数属于临界资源,这里进行增加,下面的任务线程会进行减少,可能存在冲突情况,必须加锁.

                    许可区.加锁 ()
                    运行线程数 = 运行线程数 + 1
                    许可区.解锁 ()
                    已完成任务数 = 已完成任务数 + 1


                }



            }

            // 切勿使用官方自带的 延时 命令,会导致界面卡死等问题;推荐使用精易的 程序_延时
            程序_延时 (100, )


        }
        循环判断尾 (已完成任务数 < 任务数)


        // 所有任务投放结束了,所以跳出循环了,但是还不能直接结束,因为有的线程可能还未工作完毕,所以这里要判断线程是否彻底空闲.
        循环判断首 ()
        {
            程序_延时 (100)
        }
        循环判断尾 (运行线程数 != 0)

        // 线程彻底空闲了,所有工作完成,进行结束!
        调试输出 ("任务已完成！")
        取程序 ().主窗口对象.按钮1.禁止 = 假
        返回 (0)
    }

    方法 程序_延时 <公开 静态 类型 = 逻辑型 注释 = "不占用cpu，窗口不卡死，不影响其它代码执行" 折叠 @禁止流程检查 = 真>
    参数 延时间隔 <类型 = 变整数 注释 = "留空为无限等待" @默认值 = 0>
    参数 延时单位 <类型 = 整数 注释 = "0、毫秒" 注释 = "1、秒" 注释 = "2、分钟" 注释 = "3、小时" @默认值 = 0>
    {
        @ INT_PTR Interval = @<延时间隔>, Unit = 0;
        @ if (!Interval && !Unit)
        @ {
        @ Interval = 5000 * 60 * 60;
        @ Unit = 5000 * 60 * 60;
        @ }
        @ else
        @ {
        @ switch (@<延时单位>)
        @ {
        @ case 0:
        @ Unit = 1;
        @ break;
        @ case 1:
        @ Unit = 1000;
        @ break;
        @ case 2:
        @ Unit = 1000 * 60;
        @ break;
        @ case 3:
        @ Unit = 1000 * 60 * 60;
        @ break;
        @ default:
        @ break;
        @ }
        @ }
        @ HANDLE handle[1];
        @ handle[0] = CreateWaitableTimerW(NULL, false, NULL);
        @ LARGE_INTEGER lpDueTime;
        @ lpDueTime.QuadPart = -10 * Interval * 1000 * Unit;
        @ SetWaitableTimer(handle[0], &lpDueTime, 0, NULL, NULL, false);
        @ DWORD nCount = sizeof(handle) / sizeof(HANDLE);
        @ while (MsgWaitForMultipleObjects(nCount, handle, false, -1, (QS_KEY | QS_MOUSEMOVE | QS_MOUSEBUTTON | QS_POSTMESSAGE | QS_TIMER | QS_PAINT | QS_SENDMESSAGE | QS_HOTKEY)) != WAIT_OBJECT_0)
        @ {
        系统_处理事件 ()
        @ }
        @ CloseHandle(handle[0]);
        @ return true;
    }

    方法 系统_处理事件 <公开 静态 注释 = "暂时转让控制权，以便让 Windows 操作系统有机会处理其它的如用户键盘或鼠标输入等事件。直到操作系统处理并发送完程序队列中的所有事件后，命令才会返回。"
            折叠 @禁止流程检查 = 真>
    {
        @ MSG msg;
        @ memset(&msg, 0, sizeof(MSG));
        @ while (PeekMessageW(&msg, NULL, 0, 0, PM_REMOVE))
        @ {
        @     TranslateMessage(&msg);
        @     DispatchMessageW(&msg);
        @ }
    }

    方法 任务线程 <静态 类型 = 整数 注释 = "固定格式" 返回值注释 = "固定返回值">
    参数 用户参数 <类型 = 变整数 注释 = "固定参数">
    {

        变量 加数 <类型 = 整数>
        变量 被加数 <类型 = 整数>
        加数 = (整数)用户参数 + 1

        // 检测用户是否发送了强制结束指令
        如果真 (强制结束)
        {
            调试输出 ("接收到强制结束指令，线程即将结束！")
            返回 (0)
        }

        调试输出 ("投递线程")
        程序_延时 (2000)
        // 进行窗口组件的交互,该资源属于临界资源,必须进行加锁
        // 运行线程数,这个变量也是临界资源,所以也需要进行加锁.
        许可区.加锁 ()
        被加数 = 文本到整数 (取程序 ().主窗口对象.编辑框1.内容)

        取程序 ().主窗口对象.编辑框1.内容 = 到文本 (加数 + 被加数)
        运行线程数 = 运行线程数 - 1
        许可区.解锁 ()



        返回 (0)
    }
}
