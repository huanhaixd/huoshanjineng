
###### 以下为一个火山软件开发平台系统类库程序的内容

<火山程序 类型 = "通常" 版本 = 1 />

包 水淼.命令集

类 水淼JSON辅助类 <公开 @全局类 = 真>
{
    常量 编码USC2 <公开 类型 = 整数 值 = 0 注释 = "\\u5BF9">
    常量 编码网页转义符 <公开 类型 = 整数 值 = 1 注释 = "&#x5BF9; 和 &#23545; 和 &nbsp; 解码时使用">
    常量 编码网页转义符十六进制 <公开 类型 = 整数 值 = 1 注释 = "&#23545;">
    常量 编码网页转义符十进制 <公开 类型 = 整数 值 = 2 注释 = "&#23545;">
    常量 网页转义符对照表 <公开 类型 = 文本型
            值 = "&quot; &#34;\r\n&amp; &#38;\r\n&lt; &#60;\r\n&gt; &#62;\r\n&nbsp; &#32;\r\n&iexcl; &#161;\r\n&Aacute; &#193;\r\n&aacute; &#225;\r\n&cent; &#162;\r\n&circ; &#194;\r\n&acirc; &#226;\r\n&pound; &#163;\r\n&Atilde; &#195;\r\n&atilde; &#227;\r\n&curren; &#164;\r\n&auml; &#228;\r\n&yen; &#165;\r\n&ring; &#197;\r\n&aring; &#229;\r\n&brvbar; &#166;\r\n&AElig; &#198;\r\n&aelig; &#230;\r\n&sect; &#167;\r\n&Ccedil; &#199;\r\n&ccedil; &#231;\r\n&uml; &#168;\r\n&Egrave; &#200;\r\n&egrave; &#232;\r\n&copy; &#169;\r\n&Eacute; &#201;\r\n&eacute; &#233;\r\n&ordf; &#170;\r\n&Ecirc; &#202;\r\n&ecirc; &#234;\r\n&laquo; &#171;\r\n&Euml; &#203;\r\n&euml; &#235;\r\n&not; &#172;\r\n&Igrave; &#204;\r\n&igrave; &#236;\r\n&shy; &#173;\r\n&Iacute; &#205;\r\n&iacute; &#237;\r\n&reg; &#174;\r\n&Icirc; &#206;\r\n&icirc; &#238;\r\n&macr; &#175;\r\n&Iuml; &#207;\r\n&iuml; &#239;\r\n&deg; &#176;\r\n&ETH; &#208;\r\n&ieth; &#240;\r\n&plusmn; &#177;\r\n&Ntilde; &#209;\r\n&ntilde; &#241;\r\n&sup2; &#178;\r\n&Ograve; &#210;\r\n&ograve; &#242;\r\n&sup3; &#179;\r\n&Oacute; &#211;\r\n&oacute; &#243;\r\n&acute; &#180;\r\n&Ocirc; &#212;\r\n&ocirc; &#244;\r\n&micro; &#181;\r\n&Otilde; &#213;\r\n&otilde; &#245;\r\n&para; &#182;\r\n&Ouml; &#214;\r\n&ouml; &#246;\r\n&middot; &#183;\r\n&times; &#215;\r\n&divide; &#247;\r\n&cedil; &#184;\r\n&Oslash; &#216;\r\n&oslash; &#248;\r\n&sup1; &#185;\r\n&Ugrave; &#217;\r\n&ugrave; &#249;\r\n&ordm; &#186;\r\n&Uacute; &#218;\r\n&uacute; &#250;\r\n&raquo; &#187;\r\n&Ucirc; &#219;\r\n&ucirc; &#251;\r\n&frac14; &#188;\r\n&Uuml; &#220;\r\n&uuml; &#252;\r\n&frac12; &#189;\r\n&Yacute; &#221;\r\n&yacute; &#253;\r\n&frac34; &#190;\r\n&THORN; &#222;\r\n&thorn; &#254;\r\n&iquest; &#191;\r\n&szlig; &#223;\r\n&yuml; &#255;\r\n&Agrave; &#192;\r\n&agrave; &#224;\r\n&ldquo; &#8220;\r\n&rdquo; &#8221;"
            注释 = "&nbsp;原来是160，为了兼容改成32">

    方法 水淼取中间文本 <公开 静态 类型 = 文本型 注释 = "取出前文本和后文本的中间文本" 折叠>
    参数 目标文本 <类型 = 文本型>
    参数 前文本 <类型 = 文本型 注释 = "前文本为空时，查找到目标文本的开头">
    参数 后文本 <类型 = 文本型 注释 = "后文本为空时，查找到目标文本的末尾">
    参数 开始查找位置 <类型 = 整数类 注释 = "用于循环查找。本参数既用于指定本次查找的开始位置，也用于接收下次应当的查找位置。查找无结果时返回 -2。只要开始查找位置小于 0 就可以跳出了"
            @默认值 = 空对象>
    参数 先找后文本 <类型 = 逻辑型 @默认值 = 假>
    参数 忽略大小写 <类型 = 逻辑型 @默认值 = 真>
    参数 前位置偏移 <类型 = 整数 注释 = "找到前文本后，取出中间文本时的前位置偏移量" @默认值 = 0>
    参数 后位置偏移 <类型 = 整数 注释 = "找到后文本后，取出中间文本时的后位置偏移量" @默认值 = 0>
    {
        变量 前找到位置 <类型 = 整数>
        变量 后找到位置 <类型 = 整数>
        变量 取出位置 <类型 = 整数>
        变量 取出字数 <类型 = 整数>
        如果 (先找后文本)
        {
            如果 (文本是否为空 (后文本))
            {
                后找到位置 = 取文本长度 (目标文本)
            }
            否则
            {
                后找到位置 = 寻找文本 (目标文本, 后文本, 开始查找位置.值, 忽略大小写)
            }

            如果真 (后找到位置 != -1)
            {
                如果 (文本是否为空 (前文本))
                {
                    前找到位置 = 0
                }
                否则
                {
                    前找到位置 = 倒找文本 (目标文本, 前文本, 后找到位置 - 1, 忽略大小写)
                }

                如果真 (前找到位置 != -1)
                {
                    取出位置 = 前找到位置 + 取文本长度 (前文本) + 前位置偏移
                    取出字数 = 后找到位置 - 取出位置 + 后位置偏移
                    开始查找位置.值 = 前找到位置 - 1
                    返回 (取文本中间 (目标文本, 取出位置, 取出字数))  // 12345678
                }
            }

        }
        否则
        {
            如果 (文本是否为空 (前文本))
            {
                前找到位置 = 0
            }
            否则
            {
                前找到位置 = 寻找文本 (目标文本, 前文本, 开始查找位置.值, 忽略大小写)
            }

            如果真 (前找到位置 != -1)
            {
                如果 (文本是否为空 (后文本))
                {
                    后找到位置 = 取文本长度 (目标文本)
                }
                否则
                {
                    后找到位置 = 寻找文本 (目标文本, 后文本, 前找到位置 + 取文本长度 (前文本), 忽略大小写)
                }

                如果真 (后找到位置 != -1)
                {
                    取出位置 = 前找到位置 + 取文本长度 (前文本) + 前位置偏移
                    取出字数 = 后找到位置 - 取出位置 + 后位置偏移
                    开始查找位置.值 = 后找到位置 + 取文本长度 (后文本)
                    返回 (取文本中间 (目标文本, 取出位置, 取出字数))  // 12345678
                }
            }

        }

        开始查找位置.值 = -2
        返回 ("")
    }

    方法 水淼十进制到十六进制逆序 <公开 静态 类型 = 字符数组类 注释 = "返回类型为【字符数组类】" 折叠>
    参数 十进制数值 <类型 = 整数>
    参数 补齐位数 <类型 = 整数 @默认值 = 0>
    {
        变量 进整数 <类型 = 整数>
        变量 余数 <类型 = 小数>
        变量 余整数 <类型 = 整数>
        变量 结果 <类型 = 字符数组类>
        判断循环 (十进制数值 != -1)
        {
            进整数 = 十进制数值 / 16
            余数 = (小数)十进制数值 / (小数)16 - (小数)进整数
            余整数 = (整数)(余数 * 16)
            如果 (进整数 < 16)
            {
                结果.加入成员 (水淼十进制到十六进制字符 (余整数))
                如果真 (进整数 != 0)
                {
                    结果.加入成员 (水淼十进制到十六进制字符 (进整数))
                }
                跳出循环
            }
            否则
            {
                结果.加入成员 (水淼十进制到十六进制字符 (余整数))
                十进制数值 = 进整数
            }
        }
        如果真 (补齐位数 > 0)
        {
            变量 已经位数 <类型 = 整数>
            已经位数 = 结果.取成员数 ()
            计次循环 (补齐位数 - 已经位数)
            {
                结果.加入成员 ('0')
            }

        }
        返回 (结果)
    }

    方法 水淼十进制到十六进制字符 <公开 静态 类型 = 字符 注释 = "提供数值0-15，返回字符0-F，返回类型为【字符】" 折叠>
    参数 数值 <类型 = 整数 注释 = "0-15">
    {
        // 09AF=48,57,65,70
        返回 (选择 (数值 < 10, (字符)(数值 + 48), (字符)(数值 + 65 - 10)))
    }

    方法 水淼十六进制到十进制2传入字符数组 <公开 静态 类型 = 整数 折叠>
    参数 进制文本 <类型 = 字符数组类>
    参数 UTF16逆字节 <类型 = 逻辑型 注释 = "是否支持UTF-16LE（逆向字节）的十六进制文本转成十进制。"
            注释 = "UTF16LE的单字字节集是两个字节，每个字节值转换的十六进制是2位文本，共4位文本。"
            注释 = "但是因为其将低位字节放在了第一位，高位字节放在了第二位，搞反了顺序，而进制转换是以第一位为最高位的。"
            注释 = "所以在将UTF-16LE的十六进制转成十进制之前，必须先将十六进制的4位文本的顺序调正（即前2位与后2位互换）"
            注释 = "本参数为真时，自动互换高低字节再进行进制转换，必须确保进制文本是4位，否则可能会出错。" @默认值 = 假>
    {
        变量 代码值 <类型 = 整数>
        变量 结果 <类型 = 整数>
        变量 长度 <类型 = 整数>
        长度 = 进制文本.取成员数 ()  // 09afA=48,57,97,102,65,70            3000 3900 6100 6600 8476
        计次循环 (长度)
        {
            代码值 = (整数)进制文本.取成员 (取循环索引 ())  // 第一位数x16
            如果 (代码值 >= 48 && 代码值 <= 57)  // 0-9
            {
                代码值 = 代码值 - 48
            }
            否则 (代码值 >= 97 && 代码值 <= 102)  // a-f代表10到15
            {
                代码值 = 代码值 - 97 + 10
            }
            否则
            {
                代码值 = 代码值 - 65 + 10
            }
            结果 = 结果 + 代码值 * (整数)求次方 (16, 长度 - 取循环索引 () - 1 + 选择 (UTF16逆字节, 选择 (取循环索引 () < 2, -2, 2), 0))
        }
        返回 (结果)

    }

    方法 水淼编码UCS2 <公开 静态 类型 = 文本型 注释 = "不止是UCS2，还支持网页转义符" 折叠>
    参数 文本 <类型 = 文本型>
    参数 编码ASCII字符 <类型 = 逻辑型 注释 = "<128" @默认值 = 假>
    参数 编码换行 <类型 = 逻辑型 注释 = "\\r\\n" @默认值 = 真>
    参数 编码类型 <类型 = 整数 注释 = "0、USC2(\\u5BF9) 1、网页转义符十六进制(&#x5BF9;) 2、网页转义符十进制(&#23545;)" @默认值 = 编码USC2>
    参数 仅编码基本 <类型 = 逻辑型 注释 = "编码USC2时，是否仅编码换行、引号,[]{}这些基本字符" @默认值 = 假>
    参数 不编码方花括号 <类型 = 逻辑型 注释 = "编码USC2时，是否不编码[]{}" @默认值 = 假>
    {
        变量 当前位置 <类型 = 整数>
        变量 字符串 <类型 = 字符数组类>
        变量 十六进制 <类型 = 字符数组类>
        变量 新字符串 <类型 = 字符数组类>
        变量 临时 <类型 = 文本型>
        变量 当前字符 <类型 = 字符>
        字符串.从字节集复制 (文本到字节集 (文本), 0, 取文本长度 (文本))

        当前位置 = -1
        十六进制.重置数组 (4)
        判断循环 (当前位置 + 1 < 字符串.取成员数 ())
        {
            当前位置 = 当前位置 + 1
            当前字符 = 字符串.取成员 (当前位置)
            如果 ((整数)当前字符 < 128)
            {
                如果真 (编码类型 == 编码USC2)
                {
                    如果 (当前字符 == '"' || 当前字符 == '\'' || 当前字符 == '\\' || 当前字符 == '/' || 当前字符 == '{' || 当前字符 == '}' || 当前字符 == '[' || 当前字符 == ']')
                    {
                        如果真 (不编码方花括号 && (当前字符 == '{' || 当前字符 == '}' || 当前字符 == '[' || 当前字符 == ']'))
                        {
                            新字符串.加入成员 (当前字符)
                            到循环尾

                        }
                        新字符串.加入成员 ('\\')
                        新字符串.加入成员 (当前字符)
                        到循环尾
                    }

                }

                如果 (编码ASCII字符)
                {
                    如果真 (编码换行 == 假 && (当前字符 == '\r' || 当前字符 == '\n'))
                    {
                        新字符串.加入成员 (当前字符)
                        到循环尾  // 虽然编码Ascii字符,但不编码换行

                    }
                }
                否则 (取反 (编码换行 && (当前字符 == '\r' || 当前字符 == '\n')))
                {
                    新字符串.加入成员 (当前字符)
                    到循环尾
                }

            }
            如果 (编码类型 == 编码USC2)
            {
                如果 (仅编码基本)
                {
                    如果 (当前字符 == '\r')
                    {
                        新字符串.加入成员 ('\\')
                        新字符串.加入成员 ('r')
                    }
                    否则 (当前字符 == '\n')
                    {
                        新字符串.加入成员 ('\\')
                        新字符串.加入成员 ('n')
                    }
                    否则
                    {
                        新字符串.加入成员 (当前字符)
                    }

                    到循环尾
                }
                否则
                {
                    如果 (当前字符 == '\r')
                    {
                        新字符串.加入成员 ('\\')
                        新字符串.加入成员 ('r')
                        到循环尾
                    }
                    否则 (当前字符 == '\n')
                    {
                        新字符串.加入成员 ('\\')
                        新字符串.加入成员 ('n')
                        到循环尾
                    }

                }


                新字符串.加入成员 ('\\')
                新字符串.加入成员 ('u')
            }
            否则 (编码类型 == 编码网页转义符十六进制)
            {
                新字符串.加入成员 ('&')
                新字符串.加入成员 ('#')
                新字符串.加入成员 ('x')
            }
            否则 (编码类型 == 编码网页转义符十进制)
            {
                新字符串.加入成员 ('&')
                新字符串.加入成员 ('#')
            }

            如果 (编码类型 != 编码网页转义符十进制)  // 2021年4月23日还可以进一步优化
            {
                // 新字符串.添加数组 (十进制到十六进制 ((整数)当前字符, 4))
                十六进制 = 水淼十进制到十六进制逆序 ((整数)当前字符, 4)
                计次循环 (4)
                {
                    新字符串.加入成员 (十六进制.取成员 (3 - 取循环索引 ()))
                }
            }
            否则
            {
                临时 = 到文本 ((整数)当前字符)
                新字符串.添加字节集 (到字节集 (临时), 0, 取文本长度 (临时))
                // 十六进制.从字节集复制 (到字节集 (到文本 ((整数)当前字符)), 0, 取文本长度 (到文本 ((整数)当前字符)))
                // 新字符串.添加数组 (十六进制)
            }
            如果 (编码类型 != 编码USC2)
            {
                新字符串.加入成员 (';')
            }

        }
        返回 (字节集到文本 (新字符串.取字节集 ()))
    }

    方法 水淼解码UCS2 <公开 静态 类型 = 文本型 注释 = "不止是UCS2，还支持网页转义符" 折叠>
    参数 文本 <类型 = 文本型>
    参数 编码类型 <类型 = 整数 注释 = "0、USC2(\\u5BF9) 1、网页转义符(&#x5BF9; 和 &#23545; 和 &nbsp;)" @默认值 = 编码USC2>
    {
        变量 当前位置 <类型 = 整数>
        变量 字符串 <类型 = 字符数组类>
        变量 十六进制 <类型 = 字符数组类>
        变量 偏移 <类型 = 整数>
        变量 十进制文本 <类型 = 字符数组类>
        变量 新字符串 <类型 = 字符数组类>
        变量 当前字符 <类型 = 字符>
        变量 开始位置 <类型 = 整数>
        变量 当前字符2 <类型 = 字符>
        变量 转义字符值 <类型 = 整数>
        字符串.从字节集复制 (文本到字节集 (文本), 0, 取文本长度 (文本))
        当前位置 = -1
        十六进制.重置数组 (4)
        新字符串.预分配尺寸 = 字符串.取成员数 ()
        判断循环 (当前位置 + 1 < 字符串.取成员数 ())
        {
            当前位置 = 当前位置 + 1
            当前字符 = 字符串.取成员 (当前位置)
            如果真 (编码类型 == 编码USC2 && (当前字符 == '\\' || 当前字符 == '%') || 编码类型 != 编码USC2 && 当前字符 == '&')
            {
                如果真 (当前位置 + 1 < 字符串.取成员数 ())
                {
                    如果 (字符串.取成员 (当前位置 + 1) == 选择 (编码类型 == 编码USC2, 'u', '#'))
                    {
                        如果 (编码类型 != 编码USC2)
                        {
                            如果 (当前位置 + 2 < 字符串.取成员数 () && 字符串.取成员 (当前位置 + 2) == 'x')  // &#x5BF9;
                            {
                                偏移 = 1
                            }
                            否则  // &#23545;
                            {
                                开始位置 = 当前位置
                                当前位置 = 当前位置 + 2
                                十进制文本.删除所有成员 ()
                                判断循环 (当前位置 < 字符串.取成员数 ())
                                {
                                    当前字符2 = 字符串.取成员 (当前位置)
                                    如果真 (当前字符2 == ';')
                                    {
                                        跳出循环
                                    }
                                    如果 (当前字符2 >= '0' && 当前字符2 <= '9')
                                    {
                                        十进制文本.加入成员 (当前字符2)
                                    }
                                    否则
                                    {
                                        十进制文本.删除所有成员 ()
                                        跳出循环
                                    }
                                    当前位置 = 当前位置 + 1
                                }
                                如果 (十进制文本.取成员数 () != 0)
                                {
                                    新字符串.加入成员 ((字符)文本到整数 (字节集到文本 (十进制文本.取字节集 ())))
                                    到循环尾
                                }
                                否则
                                {
                                    当前位置 = 开始位置
                                }
                                偏移 = -1  // 不允许后面再处理
                            }
                        }
                        否则
                        {
                            偏移 = 0
                        }

                        如果真 (偏移 != -1 && 当前位置 + 5 + 偏移 * 2 < 字符串.取成员数 ())  // \u5BF9    &#x5BF9;
                        {

                            十六进制.置成员值 (0, 字符串.取成员 (当前位置 + 2 + 偏移))
                            十六进制.置成员值 (1, 字符串.取成员 (当前位置 + 3 + 偏移))
                            十六进制.置成员值 (2, 字符串.取成员 (当前位置 + 4 + 偏移))
                            十六进制.置成员值 (3, 字符串.取成员 (当前位置 + 5 + 偏移))
                            // 新字符串.加入成员 ((字符)十六进制到十进制 (字节集到文本 (十六进制.取字节集 ())))
                            新字符串.加入成员 ((字符)水淼十六进制到十进制2传入字符数组 (十六进制))  // 速度比上一个快一倍
                            当前位置 = 当前位置 + 5 + 偏移 * 2
                            到循环尾
                        }
                    }
                    否则
                    {
                        如果真 (编码类型 == 编码网页转义符 || 编码类型 == 编码网页转义符十进制)  // &nbsp;
                        {

                            开始位置 = 当前位置
                            当前位置 = 当前位置 + 1
                            十进制文本.删除所有成员 ()
                            判断循环 (当前位置 < 字符串.取成员数 ())
                            {
                                当前字符2 = 字符串.取成员 (当前位置)
                                如果真 (当前字符2 == ';')
                                {
                                    跳出循环
                                }
                                如果 (当前字符2 >= '0' && 当前字符2 <= '9' || 当前字符2 >= 'a' && 当前字符2 <= 'z' || 当前字符2 >= 'A' && 当前字符2 <= 'Z')
                                {
                                    十进制文本.加入成员 (当前字符2)
                                }
                                否则
                                {
                                    十进制文本.删除所有成员 ()
                                    跳出循环
                                }
                                当前位置 = 当前位置 + 1
                            }
                            // 调试输出("oo",十进制文本)
                            如果 (十进制文本.取成员数 () != 0)
                            {
                                转义字符值 = 文本到整数 (水淼取中间文本 (网页转义符对照表, "&" + 字节集到文本 (十进制文本.取字节集 ()) + "; &#", ";", , , 假))
                                如果 (转义字符值 != 0)
                                {
                                    新字符串.加入成员 ((字符)转义字符值)
                                }
                                否则
                                {
                                    新字符串.加入成员 ('&')
                                    新字符串.添加数组 (十进制文本)
                                    新字符串.加入成员 (';')
                                }

                                到循环尾
                            }
                            否则
                            {
                                当前位置 = 开始位置
                            }
                        }
                        如果真 (编码类型 == 编码USC2 && 当前字符 == '\\')
                        {
                            如果真 (当前位置 + 1 < 字符串.取成员数 ())
                            {
                                当前位置 = 当前位置 + 1
                                如果 (字符串.取成员 (当前位置) == 'r')
                                {
                                    新字符串.加入成员 ('\r')
                                }
                                否则 (字符串.取成员 (当前位置) == 'n')
                                {
                                    新字符串.加入成员 ('\n')
                                }
                                否则
                                {
                                    新字符串.加入成员 (字符串.取成员 (当前位置))
                                }
                            }
                            到循环尾

                        }
                    }
                }
            }
            新字符串.加入成员 (当前字符)
        }
        返回 (字节集到文本 (新字符串.取字节集 ()))
    }
}
