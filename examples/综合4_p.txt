
###### 以下为一个火山软件开发平台系统类库程序的内容

<火山程序 类型 = "通常" 版本 = 1 />

包 火山.程序

类 启动类 <公开 基础类 = 窗口程序类>
{
    变量 主窗口对象 <类型 = 我的主窗口>

    方法 启动方法 <公开 类型 = 整数>
    {
        主窗口对象.创建主窗口 ()
        返回 (1)
    }
}

# ===

类 我的主窗口 <基础类 = 窗口 注释 = "样例主窗口" @视窗.布局 = "client_size = \"847, 306\"" 标题 = "WTL实现自定义表格布局案例">
{
    变量 图片框1 <类型 = 图片框 折叠2 隐藏值属性 = "0" @视窗.布局 = "id = 101\r\npos = \"17, 13, 800, 243\"" 组件边框 = 单线边框式
            背景颜色 = 0xFFFFFF>
    变量 纵向滚动条1 <类型 = 纵向滚动条 隐藏值属性 = "0" @视窗.布局 = "id = 102\r\nparent_id = 101\r\npos = \"492, 0, 19, 249\"">
    变量 数据容器 <类型 = 图片框 折叠2 隐藏值属性 = "0" @视窗.布局 = "id = 103\r\nparent_id = 101\r\npos = \"0, 0, 492, 95\""
            背景颜色 = 0xFFFFFF>
    变量 ""
    变量 测试 <类型 = 自定义样式>
    变量 ""

    方法 我的主窗口_创建完毕 <接收事件 类型 = 整数 注释 = "当本组件及其中所有子组件均被创建完毕后发送此事件.">
    参数 来源对象 <类型 = 我的主窗口 注释 = "提供事件产生的具体来源对象">
    参数 标记值 <类型 = 整数 注释 = "用户调用\"挂接事件\"命令时所提供的\"标记值\"参数值,非此方式挂接事件则本参数值固定为0.">
    {
        变量 i <类型 = 整数>
        变量 数量 <类型 = 整数 值 = 100 注释 = "数据过多.建议分页处理">
        纵向滚动条1.左边 = 图片框1.宽度 - 纵向滚动条1.宽度
        变量 高度计算 <静态 类型 = 整数 值 = 32>
        循环 (, 数量, i)
        {
            对象.对象数组.加入成员 ((自定义样式)新建对象 (自定义样式))
            变量 坐标 <静态 类型 = 整数>

            测试 = (自定义样式)对象.对象数组.取成员 (i)
            测试.创建组件 (数据容器, 坐标, 10, 图片框1.宽度 - 纵向滚动条1.宽度, 32, )
            测试.ID.标题 = 到文本 (i + 1)
            测试.标题1.标题 = "我是自定义样式" + 到文本 (i + 1)
            测试.选择框1.禁止 = 真
            测试.底色 = 颜色类.白色
            测试.ID.背景颜色 = 颜色类.白色
            测试.标题1.背景颜色 = 颜色类.白色
            测试.选择框1.背景颜色 = 颜色类.白色
            测试.移动 (0, 测试.顶边 + i / 1 * (测试.高度 + 0) - 10, , )

            数据容器.宽度 = 测试.左边 + 测试.宽度 + 10
            数据容器.高度 = 测试.顶边 + 测试.高度 + 10
            变量 累计 <静态 类型 = 整数>
            如果 (累计 == 行数)
            {
                累计 = 0
                高度计算 = 测试.顶边 + 32  // 高度计算 + 32
            }
            否则
            {
                累计 = 累计 + 1
            }

            坐标 = 坐标 + 100

        }


        循环 (, 对象.对象数组.取成员数 (), i)
        {
            挂接事件 ((自定义样式)对象.对象数组.取成员 (i), i)
        }


        纵向滚动条1.最大位置 = 高度计算

        返回 (0)
    }

    方法 "// 横向滚动条_位置被改变" <接收事件 类型 = 整数 注释 = "当滚动条位置被改变后本事件被发送" 折叠>
    参数 来源对象 <类型 = 横向滚动条 注释 = "提供事件产生的具体来源对象">
    参数 标记值 <类型 = 整数 注释 = "用户调用\"挂接事件\"命令时所提供的\"标记值\"参数值,非此方式挂接事件则本参数值固定为0.">
    {
        // 如果 (来源对象 == 横向滚动条1)
        {
            // 数据容器.移动 (-来源对象.位置, -纵向滚动条1.位置)
        }
        // 返回 (0)
    }

    方法 纵向滚动条_位置被改变 <接收事件 类型 = 整数 注释 = "当滚动条位置被改变后本事件被发送" 折叠>
    参数 来源对象 <类型 = 纵向滚动条 注释 = "提供事件产生的具体来源对象">
    参数 标记值 <类型 = 整数 注释 = "用户调用\"挂接事件\"命令时所提供的\"标记值\"参数值,非此方式挂接事件则本参数值固定为0.">
    {
        如果 (来源对象 == 纵向滚动条1)
        {
            数据容器.移动 (0, -来源对象.位置)
        }
        返回 (0)
    }

    方法 标签_鼠标左键被按下 <接收事件 类型 = 整数 注释 = "当鼠标左键被按下时事件被触发" 返回值注释 = "本事件的处理方法如果返回非0整数值,表明事件已经得到处理且不再需要后续处理." 折叠>
    参数 来源对象 <类型 = 标签 注释 = "提供事件产生的具体来源对象">
    参数 标记值 <类型 = 整数 注释 = "用户调用\"挂接事件\"命令时所提供的\"标记值\"参数值,非此方式挂接事件则本参数值固定为0.">
    参数 横向位置 <类型 = 整数 注释 = "事件触发时的鼠标横向坐标位置,相对所处用户区的左边.">
    参数 纵向位置 <类型 = 整数 注释 = "事件触发时的鼠标纵向坐标位置,相对所处用户区的顶边.">
    参数 辅助键状态 <类型 = 整数 注释 = "事件触发时的辅助键组合状态,为\"辅助键状态\"类中各常量值的组合.">
    {

        返回 (0)
    }

    方法 按钮_被单击 <接收事件 类型 = 整数 注释 = "当按钮被单击后发送此事件" 折叠>
    参数 来源对象 <类型 = 按钮 注释 = "提供事件产生的具体来源对象">
    参数 标记值 <类型 = 整数 注释 = "用户调用\"挂接事件\"命令时所提供的\"标记值\"参数值,非此方式挂接事件则本参数值固定为0.">
    {
        调试输出 (555)
        返回 (0)
    }

    方法 图片框_滚轮被滚动 <接收事件 类型 = 整数 注释 = "当鼠标滚轮被滚动时事件被触发" 返回值注释 = "本事件的处理方法如果返回非0整数值,表明事件已经得到处理且不再需要后续处理." 折叠>
    参数 来源对象 <类型 = 图片框 注释 = "提供事件产生的具体来源对象">
    参数 标记值 <类型 = 整数 注释 = "用户调用\"挂接事件\"命令时所提供的\"标记值\"参数值,非此方式挂接事件则本参数值固定为0.">
    参数 滚动距离 <类型 = 整数 注释 = "表明鼠标滚轮所滚动的距离,大于零表示向前滚动,小于零表示向后滚动.">
    参数 辅助键状态 <类型 = 整数 注释 = "事件触发时的辅助键组合状态,为\"辅助键状态\"类中各常量值的组合.">
    {
        如果真 (滚动距离 == -1)
        {
            如果真 (纵向滚动条1.位置 != 0)
            {
                纵向滚动条1.位置 = 纵向滚动条1.位置 + 5
            }

        }

        如果真 (滚动距离 == 1)
        {
            纵向滚动条1.位置 = 纵向滚动条1.位置 - 5
        }

        数据容器.移动 (0, -纵向滚动条1.位置)

        返回 (0)
    }

    方法 组件布局器_创建完毕 <接收事件 类型 = 整数 注释 = "当本组件及其中所有子组件均被创建完毕后发送此事件." 折叠>
    参数 来源对象 <类型 = 组件布局器 注释 = "提供事件产生的具体来源对象">
    参数 标记值 <类型 = 整数 注释 = "用户调用\"挂接事件\"命令时所提供的\"标记值\"参数值,非此方式挂接事件则本参数值固定为0.">
    {
        // 如果 (来源对象 == 测试)
        {

        }
        返回 (0)
    }

    变量 选择框1 <类型 = 选择框 注释 = "继承 判断点击">
    变量 标签1 <类型 = 标签 注释 = "继承 判断点击">
    变量 编辑框1 <类型 = 编辑框 注释 = "继承 输入">

    方法 自定义样式_鼠标左键被按下 <接收事件 类型 = 整数 注释 = "当鼠标左键被按下时事件被触发" 返回值注释 = "本事件的处理方法如果返回非0整数值,表明事件已经得到处理且不再需要后续处理.">
    参数 来源对象 <类型 = 自定义样式 注释 = "提供事件产生的具体来源对象">
    参数 标记值 <类型 = 整数 注释 = "用户调用\"挂接事件\"命令时所提供的\"标记值\"参数值,非此方式挂接事件则本参数值固定为0.">
    参数 横向位置 <类型 = 整数 注释 = "事件触发时的鼠标横向坐标位置,相对所处用户区的左边.">
    参数 纵向位置 <类型 = 整数 注释 = "事件触发时的鼠标纵向坐标位置,相对所处用户区的顶边.">
    参数 辅助键状态 <类型 = 整数 注释 = "事件触发时的辅助键组合状态,为\"辅助键状态\"类中各常量值的组合.">
    {
        变量 i <类型 = 整数>
        来源对象.底色 = 颜色类.浅灰色  // 选择颜色
        变量 临时1 <类型 = 自定义样式>
        临时1 = (自定义样式)对象.对象数组.取成员 (标记值)
        临时1.标题1.背景颜色 = 颜色类.浅灰色
        临时1.ID.背景颜色 = 颜色类.浅灰色
        临时1.选择框1.背景颜色 = 颜色类.浅灰色
        临时1.选择框1.禁止 = 假
        临时1.编辑框1.禁止 = 假
        // 继承列表组件
        编辑框1 = (编辑框)新建对象 (编辑框)
        编辑框1 = 临时1.编辑框1
        挂接事件 (编辑框1, 标记值)

        选择框1 = (选择框)新建对象 (选择框)
        选择框1 = 临时1.选择框1
        挂接事件 (选择框1, 标记值)

        标签1 = (标签)新建对象 (标签)
        标签1 = 临时1.标题1
        挂接事件 (标签1, 标记值)

        循环 (, 对象.对象数组.取成员数 (), i)
        {
            如果真 (i != 标记值)  // 选择取消颜色
            {
                变量 临时 <类型 = 自定义样式>
                临时 = (自定义样式)对象.对象数组.取成员 (i)
                临时.底色 = 颜色类.白色
                临时.标题1.背景颜色 = 颜色类.白色
                临时.ID.背景颜色 = 颜色类.白色
                临时.选择框1.背景颜色 = 颜色类.白色
                临时.选择框1.禁止 = 真
                临时.编辑框1.禁止 = 真
            }

        }

        返回 (0)
    }

    方法 选择框_被单击 <接收事件 类型 = 整数 注释 = "当按钮被单击后发送此事件">
    参数 来源对象 <类型 = 选择框 注释 = "提供事件产生的具体来源对象">
    参数 标记值 <类型 = 整数 注释 = "用户调用\"挂接事件\"命令时所提供的\"标记值\"参数值,非此方式挂接事件则本参数值固定为0.">
    {
        调试输出 (标签1.标题)
        变量 临时1 <类型 = 自定义样式>
        临时1 = (自定义样式)对象.对象数组.取成员 (标记值)
        如果 (来源对象.选中 == 真)
        {
            临时1.选择框1.选中 = 真
            全局信息框 ("选择：" + 临时1.标题1.标题 + "   已保存编辑框内容:" + 临时1.编辑框1.内容)
        }
        否则
        {
            临时1.选择框1.选中 = 假
            全局信息框 ("选择取消：")
        }
        返回 (0)
    }

    方法 编辑框_内容被改变 <接收事件 类型 = 整数 注释 = "编辑框内容被改变后本事件被发送">
    参数 来源对象 <类型 = 编辑框 注释 = "提供事件产生的具体来源对象">
    参数 标记值 <类型 = 整数 注释 = "用户调用\"挂接事件\"命令时所提供的\"标记值\"参数值,非此方式挂接事件则本参数值固定为0.">
    {
        变量 临时1 <类型 = 自定义样式>
        临时1 = (自定义样式)对象.对象数组.取成员 (标记值)
        如果 (来源对象 == 编辑框1)
        {
            调试输出 (来源对象.内容)
            如果真 (来源对象.内容 != "")
            {
                // 临时1.编辑框1.内容 = 来源对象.内容
                // 全局信息框 ("编辑框内容:" + 来源对象.内容)

            }


        }
        返回 (0)
    }
}

类 自定义样式 <公开 基础类 = 组件布局器 隐藏值属性 = "0" @视窗.布局 = "client_size = \"781, 26\"">
{
    变量 ID <公开 类型 = 标签 折叠2 隐藏值属性 = "0" @视窗.布局 = "id = 101\r\npos = \"6, 6, 19, 19\"" 纵向对齐方式 = 居中 禁止 = 真>
    变量 标题1 <公开 类型 = 标签 折叠2 隐藏值属性 = "0" @视窗.布局 = "id = 102\r\npos = \"32, 6, 371, 19\"" 纵向对齐方式 = 居中 禁止 = 真>
    变量 选择框1 <公开 类型 = 选择框 折叠2 隐藏值属性 = "0" @视窗.布局 = "id = 103\r\npos = \"410, 6, 58, 19\"" 标题 = "保存"
            横向对齐方式 = 居中 纵向对齐方式 = 居中>
    变量 编辑框1 <公开 类型 = 编辑框 折叠2 隐藏值属性 = "0" @视窗.布局 = "id = 104\r\npos = \"480, 6, 275, 19\"" 禁止 = 真>
}

类 对象 <公开 折叠>
{
    变量 对象数组 <公开 静态 类型 = 对象数组类>
}

【分隔符】


###### 以下为一个火山软件开发平台系统类库程序的内容

<火山程序 类型 = "通常" 版本 = 1 />

包 水淼.命令集

类 水淼JSON辅助类 <公开 @全局类 = 真>
{
    常量 编码USC2 <公开 类型 = 整数 值 = 0 注释 = "\\u5BF9">
    常量 编码网页转义符 <公开 类型 = 整数 值 = 1 注释 = "&#x5BF9; 和 &#23545; 和 &nbsp; 解码时使用">
    常量 编码网页转义符十六进制 <公开 类型 = 整数 值 = 1 注释 = "&#23545;">
    常量 编码网页转义符十进制 <公开 类型 = 整数 值 = 2 注释 = "&#23545;">
    常量 网页转义符对照表 <公开 类型 = 文本型
            值 = "&quot; &#34;\r\n&amp; &#38;\r\n&lt; &#60;\r\n&gt; &#62;\r\n&nbsp; &#32;\r\n&iexcl; &#161;\r\n&Aacute; &#193;\r\n&aacute; &#225;\r\n&cent; &#162;\r\n&circ; &#194;\r\n&acirc; &#226;\r\n&pound; &#163;\r\n&Atilde; &#195;\r\n&atilde; &#227;\r\n&curren; &#164;\r\n&auml; &#228;\r\n&yen; &#165;\r\n&ring; &#197;\r\n&aring; &#229;\r\n&brvbar; &#166;\r\n&AElig; &#198;\r\n&aelig; &#230;\r\n&sect; &#167;\r\n&Ccedil; &#199;\r\n&ccedil; &#231;\r\n&uml; &#168;\r\n&Egrave; &#200;\r\n&egrave; &#232;\r\n&copy; &#169;\r\n&Eacute; &#201;\r\n&eacute; &#233;\r\n&ordf; &#170;\r\n&Ecirc; &#202;\r\n&ecirc; &#234;\r\n&laquo; &#171;\r\n&Euml; &#203;\r\n&euml; &#235;\r\n&not; &#172;\r\n&Igrave; &#204;\r\n&igrave; &#236;\r\n&shy; &#173;\r\n&Iacute; &#205;\r\n&iacute; &#237;\r\n&reg; &#174;\r\n&Icirc; &#206;\r\n&icirc; &#238;\r\n&macr; &#175;\r\n&Iuml; &#207;\r\n&iuml; &#239;\r\n&deg; &#176;\r\n&ETH; &#208;\r\n&ieth; &#240;\r\n&plusmn; &#177;\r\n&Ntilde; &#209;\r\n&ntilde; &#241;\r\n&sup2; &#178;\r\n&Ograve; &#210;\r\n&ograve; &#242;\r\n&sup3; &#179;\r\n&Oacute; &#211;\r\n&oacute; &#243;\r\n&acute; &#180;\r\n&Ocirc; &#212;\r\n&ocirc; &#244;\r\n&micro; &#181;\r\n&Otilde; &#213;\r\n&otilde; &#245;\r\n&para; &#182;\r\n&Ouml; &#214;\r\n&ouml; &#246;\r\n&middot; &#183;\r\n&times; &#215;\r\n&divide; &#247;\r\n&cedil; &#184;\r\n&Oslash; &#216;\r\n&oslash; &#248;\r\n&sup1; &#185;\r\n&Ugrave; &#217;\r\n&ugrave; &#249;\r\n&ordm; &#186;\r\n&Uacute; &#218;\r\n&uacute; &#250;\r\n&raquo; &#187;\r\n&Ucirc; &#219;\r\n&ucirc; &#251;\r\n&frac14; &#188;\r\n&Uuml; &#220;\r\n&uuml; &#252;\r\n&frac12; &#189;\r\n&Yacute; &#221;\r\n&yacute; &#253;\r\n&frac34; &#190;\r\n&THORN; &#222;\r\n&thorn; &#254;\r\n&iquest; &#191;\r\n&szlig; &#223;\r\n&yuml; &#255;\r\n&Agrave; &#192;\r\n&agrave; &#224;\r\n&ldquo; &#8220;\r\n&rdquo; &#8221;"
            注释 = "&nbsp;原来是160，为了兼容改成32">

    方法 水淼取中间文本 <公开 静态 类型 = 文本型 注释 = "取出前文本和后文本的中间文本" 折叠>
    参数 目标文本 <类型 = 文本型>
    参数 前文本 <类型 = 文本型 注释 = "前文本为空时，查找到目标文本的开头">
    参数 后文本 <类型 = 文本型 注释 = "后文本为空时，查找到目标文本的末尾">
    参数 开始查找位置 <类型 = 整数类 注释 = "用于循环查找。本参数既用于指定本次查找的开始位置，也用于接收下次应当的查找位置。查找无结果时返回 -2。只要开始查找位置小于 0 就可以跳出了"
            @默认值 = 空对象>
    参数 先找后文本 <类型 = 逻辑型 @默认值 = 假>
    参数 忽略大小写 <类型 = 逻辑型 @默认值 = 真>
    参数 前位置偏移 <类型 = 整数 注释 = "找到前文本后，取出中间文本时的前位置偏移量" @默认值 = 0>
    参数 后位置偏移 <类型 = 整数 注释 = "找到后文本后，取出中间文本时的后位置偏移量" @默认值 = 0>
    {
        变量 前找到位置 <类型 = 整数>
        变量 后找到位置 <类型 = 整数>
        变量 取出位置 <类型 = 整数>
        变量 取出字数 <类型 = 整数>
        如果 (先找后文本)
        {
            如果 (文本是否为空 (后文本))
            {
                后找到位置 = 取文本长度 (目标文本)
            }
            否则
            {
                后找到位置 = 寻找文本 (目标文本, 后文本, 开始查找位置.值, 忽略大小写)
            }

            如果真 (后找到位置 != -1)
            {
                如果 (文本是否为空 (前文本))
                {
                    前找到位置 = 0
                }
                否则
                {
                    前找到位置 = 倒找文本 (目标文本, 前文本, 后找到位置 - 1, 忽略大小写)
                }

                如果真 (前找到位置 != -1)
                {
                    取出位置 = 前找到位置 + 取文本长度 (前文本) + 前位置偏移
                    取出字数 = 后找到位置 - 取出位置 + 后位置偏移
                    开始查找位置.值 = 前找到位置 - 1
                    返回 (取文本中间 (目标文本, 取出位置, 取出字数))  // 12345678
                }
            }

        }
        否则
        {
            如果 (文本是否为空 (前文本))
            {
                前找到位置 = 0
            }
            否则
            {
                前找到位置 = 寻找文本 (目标文本, 前文本, 开始查找位置.值, 忽略大小写)
            }

            如果真 (前找到位置 != -1)
            {
                如果 (文本是否为空 (后文本))
                {
                    后找到位置 = 取文本长度 (目标文本)
                }
                否则
                {
                    后找到位置 = 寻找文本 (目标文本, 后文本, 前找到位置 + 取文本长度 (前文本), 忽略大小写)
                }

                如果真 (后找到位置 != -1)
                {
                    取出位置 = 前找到位置 + 取文本长度 (前文本) + 前位置偏移
                    取出字数 = 后找到位置 - 取出位置 + 后位置偏移
                    开始查找位置.值 = 后找到位置 + 取文本长度 (后文本)
                    返回 (取文本中间 (目标文本, 取出位置, 取出字数))  // 12345678
                }
            }

        }

        开始查找位置.值 = -2
        返回 ("")
    }

    方法 水淼十进制到十六进制逆序 <公开 静态 类型 = 字符数组类 注释 = "返回类型为【字符数组类】" 折叠>
    参数 十进制数值 <类型 = 整数>
    参数 补齐位数 <类型 = 整数 @默认值 = 0>
    {
        变量 进整数 <类型 = 整数>
        变量 余数 <类型 = 小数>
        变量 余整数 <类型 = 整数>
        变量 结果 <类型 = 字符数组类>
        判断循环 (十进制数值 != -1)
        {
            进整数 = 十进制数值 / 16
            余数 = (小数)十进制数值 / (小数)16 - (小数)进整数
            余整数 = (整数)(余数 * 16)
            如果 (进整数 < 16)
            {
                结果.加入成员 (水淼十进制到十六进制字符 (余整数))
                如果真 (进整数 != 0)
                {
                    结果.加入成员 (水淼十进制到十六进制字符 (进整数))
                }
                跳出循环
            }
            否则
            {
                结果.加入成员 (水淼十进制到十六进制字符 (余整数))
                十进制数值 = 进整数
            }
        }
        如果真 (补齐位数 > 0)
        {
            变量 已经位数 <类型 = 整数>
            已经位数 = 结果.取成员数 ()
            计次循环 (补齐位数 - 已经位数)
            {
                结果.加入成员 ('0')
            }

        }
        返回 (结果)
    }

    方法 水淼十进制到十六进制字符 <公开 静态 类型 = 字符 注释 = "提供数值0-15，返回字符0-F，返回类型为【字符】" 折叠>
    参数 数值 <类型 = 整数 注释 = "0-15">
    {
        // 09AF=48,57,65,70
        返回 (选择 (数值 < 10, (字符)(数值 + 48), (字符)(数值 + 65 - 10)))
    }

    方法 水淼十六进制到十进制2传入字符数组 <公开 静态 类型 = 整数 折叠>
    参数 进制文本 <类型 = 字符数组类>
    参数 UTF16逆字节 <类型 = 逻辑型 注释 = "是否支持UTF-16LE（逆向字节）的十六进制文本转成十进制。"
            注释 = "UTF16LE的单字字节集是两个字节，每个字节值转换的十六进制是2位文本，共4位文本。"
            注释 = "但是因为其将低位字节放在了第一位，高位字节放在了第二位，搞反了顺序，而进制转换是以第一位为最高位的。"
            注释 = "所以在将UTF-16LE的十六进制转成十进制之前，必须先将十六进制的4位文本的顺序调正（即前2位与后2位互换）"
            注释 = "本参数为真时，自动互换高低字节再进行进制转换，必须确保进制文本是4位，否则可能会出错。" @默认值 = 假>
    {
        变量 代码值 <类型 = 整数>
        变量 结果 <类型 = 整数>
        变量 长度 <类型 = 整数>
        长度 = 进制文本.取成员数 ()  // 09afA=48,57,97,102,65,70            3000 3900 6100 6600 8476
        计次循环 (长度)
        {
            代码值 = (整数)进制文本.取成员 (取循环索引 ())  // 第一位数x16
            如果 (代码值 >= 48 && 代码值 <= 57)  // 0-9
            {
                代码值 = 代码值 - 48
            }
            否则 (代码值 >= 97 && 代码值 <= 102)  // a-f代表10到15
            {
                代码值 = 代码值 - 97 + 10
            }
            否则
            {
                代码值 = 代码值 - 65 + 10
            }
            结果 = 结果 + 代码值 * (整数)求次方 (16, 长度 - 取循环索引 () - 1 + 选择 (UTF16逆字节, 选择 (取循环索引 () < 2, -2, 2), 0))
        }
        返回 (结果)

    }

    方法 水淼编码UCS2 <公开 静态 类型 = 文本型 注释 = "不止是UCS2，还支持网页转义符" 折叠>
    参数 文本 <类型 = 文本型>
    参数 编码ASCII字符 <类型 = 逻辑型 注释 = "<128" @默认值 = 假>
    参数 编码换行 <类型 = 逻辑型 注释 = "\\r\\n" @默认值 = 真>
    参数 编码类型 <类型 = 整数 注释 = "0、USC2(\\u5BF9) 1、网页转义符十六进制(&#x5BF9;) 2、网页转义符十进制(&#23545;)" @默认值 = 编码USC2>
    参数 仅编码基本 <类型 = 逻辑型 注释 = "编码USC2时，是否仅编码换行、引号,[]{}这些基本字符" @默认值 = 假>
    参数 不编码方花括号 <类型 = 逻辑型 注释 = "编码USC2时，是否不编码[]{}" @默认值 = 假>
    {
        变量 当前位置 <类型 = 整数>
        变量 字符串 <类型 = 字符数组类>
        变量 十六进制 <类型 = 字符数组类>
        变量 新字符串 <类型 = 字符数组类>
        变量 临时 <类型 = 文本型>
        变量 当前字符 <类型 = 字符>
        字符串.从字节集复制 (文本到字节集 (文本), 0, 取文本长度 (文本))

        当前位置 = -1
        十六进制.重置数组 (4)
        判断循环 (当前位置 + 1 < 字符串.取成员数 ())
        {
            当前位置 = 当前位置 + 1
            当前字符 = 字符串.取成员 (当前位置)
            如果 ((整数)当前字符 < 128)
            {
                如果真 (编码类型 == 编码USC2)
                {
                    如果 (当前字符 == '"' || 当前字符 == '\'' || 当前字符 == '\\' || 当前字符 == '/' || 当前字符 == '{' || 当前字符 == '}' || 当前字符 == '[' || 当前字符 == ']')
                    {
                        如果真 (不编码方花括号 && (当前字符 == '{' || 当前字符 == '}' || 当前字符 == '[' || 当前字符 == ']'))
                        {
                            新字符串.加入成员 (当前字符)
                            到循环尾

                        }
                        新字符串.加入成员 ('\\')
                        新字符串.加入成员 (当前字符)
                        到循环尾
                    }

                }

                如果 (编码ASCII字符)
                {
                    如果真 (编码换行 == 假 && (当前字符 == '\r' || 当前字符 == '\n'))
                    {
                        新字符串.加入成员 (当前字符)
                        到循环尾  // 虽然编码Ascii字符,但不编码换行

                    }
                }
                否则 (取反 (编码换行 && (当前字符 == '\r' || 当前字符 == '\n')))
                {
                    新字符串.加入成员 (当前字符)
                    到循环尾
                }

            }
            如果 (编码类型 == 编码USC2)
            {
                如果 (仅编码基本)
                {
                    如果 (当前字符 == '\r')
                    {
                        新字符串.加入成员 ('\\')
                        新字符串.加入成员 ('r')
                    }
                    否则 (当前字符 == '\n')
                    {
                        新字符串.加入成员 ('\\')
                        新字符串.加入成员 ('n')
                    }
                    否则
                    {
                        新字符串.加入成员 (当前字符)
                    }

                    到循环尾
                }
                否则
                {
                    如果 (当前字符 == '\r')
                    {
                        新字符串.加入成员 ('\\')
                        新字符串.加入成员 ('r')
                        到循环尾
                    }
                    否则 (当前字符 == '\n')
                    {
                        新字符串.加入成员 ('\\')
                        新字符串.加入成员 ('n')
                        到循环尾
                    }

                }


                新字符串.加入成员 ('\\')
                新字符串.加入成员 ('u')
            }
            否则 (编码类型 == 编码网页转义符十六进制)
            {
                新字符串.加入成员 ('&')
                新字符串.加入成员 ('#')
                新字符串.加入成员 ('x')
            }
            否则 (编码类型 == 编码网页转义符十进制)
            {
                新字符串.加入成员 ('&')
                新字符串.加入成员 ('#')
            }

            如果 (编码类型 != 编码网页转义符十进制)  // 2021年4月23日还可以进一步优化
            {
                // 新字符串.添加数组 (十进制到十六进制 ((整数)当前字符, 4))
                十六进制 = 水淼十进制到十六进制逆序 ((整数)当前字符, 4)
                计次循环 (4)
                {
                    新字符串.加入成员 (十六进制.取成员 (3 - 取循环索引 ()))
                }
            }
            否则
            {
                临时 = 到文本 ((整数)当前字符)
                新字符串.添加字节集 (到字节集 (临时), 0, 取文本长度 (临时))
                // 十六进制.从字节集复制 (到字节集 (到文本 ((整数)当前字符)), 0, 取文本长度 (到文本 ((整数)当前字符)))
                // 新字符串.添加数组 (十六进制)
            }
            如果 (编码类型 != 编码USC2)
            {
                新字符串.加入成员 (';')
            }

        }
        返回 (字节集到文本 (新字符串.取字节集 ()))
    }

    方法 水淼解码UCS2 <公开 静态 类型 = 文本型 注释 = "不止是UCS2，还支持网页转义符" 折叠>
    参数 文本 <类型 = 文本型>
    参数 编码类型 <类型 = 整数 注释 = "0、USC2(\\u5BF9) 1、网页转义符(&#x5BF9; 和 &#23545; 和 &nbsp;)" @默认值 = 编码USC2>
    {
        变量 当前位置 <类型 = 整数>
        变量 字符串 <类型 = 字符数组类>
        变量 十六进制 <类型 = 字符数组类>
        变量 偏移 <类型 = 整数>
        变量 十进制文本 <类型 = 字符数组类>
        变量 新字符串 <类型 = 字符数组类>
        变量 当前字符 <类型 = 字符>
        变量 开始位置 <类型 = 整数>
        变量 当前字符2 <类型 = 字符>
        变量 转义字符值 <类型 = 整数>
        字符串.从字节集复制 (文本到字节集 (文本), 0, 取文本长度 (文本))
        当前位置 = -1
        十六进制.重置数组 (4)
        新字符串.预分配尺寸 = 字符串.取成员数 ()
        判断循环 (当前位置 + 1 < 字符串.取成员数 ())
        {
            当前位置 = 当前位置 + 1
            当前字符 = 字符串.取成员 (当前位置)
            如果真 (编码类型 == 编码USC2 && (当前字符 == '\\' || 当前字符 == '%') || 编码类型 != 编码USC2 && 当前字符 == '&')
            {
                如果真 (当前位置 + 1 < 字符串.取成员数 ())
                {
                    如果 (字符串.取成员 (当前位置 + 1) == 选择 (编码类型 == 编码USC2, 'u', '#'))
                    {
                        如果 (编码类型 != 编码USC2)
                        {
                            如果 (当前位置 + 2 < 字符串.取成员数 () && 字符串.取成员 (当前位置 + 2) == 'x')  // &#x5BF9;
                            {
                                偏移 = 1
                            }
                            否则  // &#23545;
                            {
                                开始位置 = 当前位置
                                当前位置 = 当前位置 + 2
                                十进制文本.删除所有成员 ()
                                判断循环 (当前位置 < 字符串.取成员数 ())
                                {
                                    当前字符2 = 字符串.取成员 (当前位置)
                                    如果真 (当前字符2 == ';')
                                    {
                                        跳出循环
                                    }
                                    如果 (当前字符2 >= '0' && 当前字符2 <= '9')
                                    {
                                        十进制文本.加入成员 (当前字符2)
                                    }
                                    否则
                                    {
                                        十进制文本.删除所有成员 ()
                                        跳出循环
                                    }
                                    当前位置 = 当前位置 + 1
                                }
                                如果 (十进制文本.取成员数 () != 0)
                                {
                                    新字符串.加入成员 ((字符)文本到整数 (字节集到文本 (十进制文本.取字节集 ())))
                                    到循环尾
                                }
                                否则
                                {
                                    当前位置 = 开始位置
                                }
                                偏移 = -1  // 不允许后面再处理
                            }
                        }
                        否则
                        {
                            偏移 = 0
                        }

                        如果真 (偏移 != -1 && 当前位置 + 5 + 偏移 * 2 < 字符串.取成员数 ())  // \u5BF9    &#x5BF9;
                        {

                            十六进制.置成员值 (0, 字符串.取成员 (当前位置 + 2 + 偏移))
                            十六进制.置成员值 (1, 字符串.取成员 (当前位置 + 3 + 偏移))
                            十六进制.置成员值 (2, 字符串.取成员 (当前位置 + 4 + 偏移))
                            十六进制.置成员值 (3, 字符串.取成员 (当前位置 + 5 + 偏移))
                            // 新字符串.加入成员 ((字符)十六进制到十进制 (字节集到文本 (十六进制.取字节集 ())))
                            新字符串.加入成员 ((字符)水淼十六进制到十进制2传入字符数组 (十六进制))  // 速度比上一个快一倍
                            当前位置 = 当前位置 + 5 + 偏移 * 2
                            到循环尾
                        }
                    }
                    否则
                    {
                        如果真 (编码类型 == 编码网页转义符 || 编码类型 == 编码网页转义符十进制)  // &nbsp;
                        {

                            开始位置 = 当前位置
                            当前位置 = 当前位置 + 1
                            十进制文本.删除所有成员 ()
                            判断循环 (当前位置 < 字符串.取成员数 ())
                            {
                                当前字符2 = 字符串.取成员 (当前位置)
                                如果真 (当前字符2 == ';')
                                {
                                    跳出循环
                                }
                                如果 (当前字符2 >= '0' && 当前字符2 <= '9' || 当前字符2 >= 'a' && 当前字符2 <= 'z' || 当前字符2 >= 'A' && 当前字符2 <= 'Z')
                                {
                                    十进制文本.加入成员 (当前字符2)
                                }
                                否则
                                {
                                    十进制文本.删除所有成员 ()
                                    跳出循环
                                }
                                当前位置 = 当前位置 + 1
                            }
                            // 调试输出("oo",十进制文本)
                            如果 (十进制文本.取成员数 () != 0)
                            {
                                转义字符值 = 文本到整数 (水淼取中间文本 (网页转义符对照表, "&" + 字节集到文本 (十进制文本.取字节集 ()) + "; &#", ";", , , 假))
                                如果 (转义字符值 != 0)
                                {
                                    新字符串.加入成员 ((字符)转义字符值)
                                }
                                否则
                                {
                                    新字符串.加入成员 ('&')
                                    新字符串.添加数组 (十进制文本)
                                    新字符串.加入成员 (';')
                                }

                                到循环尾
                            }
                            否则
                            {
                                当前位置 = 开始位置
                            }
                        }
                        如果真 (编码类型 == 编码USC2 && 当前字符 == '\\')
                        {
                            如果真 (当前位置 + 1 < 字符串.取成员数 ())
                            {
                                当前位置 = 当前位置 + 1
                                如果 (字符串.取成员 (当前位置) == 'r')
                                {
                                    新字符串.加入成员 ('\r')
                                }
                                否则 (字符串.取成员 (当前位置) == 'n')
                                {
                                    新字符串.加入成员 ('\n')
                                }
                                否则
                                {
                                    新字符串.加入成员 (字符串.取成员 (当前位置))
                                }
                            }
                            到循环尾

                        }
                    }
                }
            }
            新字符串.加入成员 (当前字符)
        }
        返回 (字节集到文本 (新字符串.取字节集 ()))
    }
}

【分隔符】


###### 以下为一个火山软件开发平台系统类库程序的内容

<火山程序 类型 = "通常" 版本 = 1 />

包 火山.程序

类 启动类 <公开 基础类 = 窗口程序类>
{
    变量 主窗口对象 <类型 = 我的主窗口 标题 = "【世恒带你学火山】- 在画板上画出股票K线图">

    方法 启动方法 <公开 类型 = 整数>
    {
        主窗口对象.创建主窗口 ()
        返回 (1)
    }
}

# ===

类 我的主窗口 <基础类 = 窗口 注释 = "样例主窗口" @视窗.布局 = "client_size = \"1024, 768\"" 标题 = "【世恒带你学火山】- 在画板上画出股票K线图">
{
    变量 画板1 <类型 = 画板 折叠2 隐藏值属性 = "0" @视窗.布局 = "id = 101\r\npos = \"2, 0, 1020, 766\"" 自动重画 = 真 画板背景色 = 0x0>
    变量 时钟1 <类型 = 时钟 隐藏值属性 = "0" @视窗.布局 = "id = 102\r\npos = \"141, 95, 72, 48\"">
    变量 成员_JSON总 <类型 = JSON对象类>
    变量 成员_JSON数组 <类型 = JSON数组类>
    变量 成员_昨日收盘价 <类型 = 小数>

    方法 我的主窗口_创建完毕 <接收事件 类型 = 整数 注释 = "当本组件及其中所有子组件均被创建完毕后发送此事件.">
    参数 来源对象 <类型 = 我的主窗口 注释 = "提供事件产生的具体来源对象">
    参数 标记值 <类型 = 整数 注释 = "用户调用\"挂接事件\"命令时所提供的\"标记值\"参数值,非此方式挂接事件则本参数值固定为0.">
    {
        如果真 (文件是否存在 (取当前目录 () + "\\600822-上海物贸.json") == 假)
        {
            结束 ()

        }
        成员_JSON总.创建自文本 (UTF8到文本 (读入文件 (取当前目录 () + "\\600822-上海物贸.json")))
        成员_昨日收盘价 = 文本到小数 (成员_JSON总.取文本值 ("昨日收盘"))
        成员_JSON总.取数组值 ("今日数据", 成员_JSON数组)
        如果真 (成员_JSON数组.成员数 < 48)
        {
            结束 ()
        }
        方法_画框架 ()
        时钟1.时钟周期 = 200

        返回 (0)
    }

    方法 方法_画框架
    {
        画板1.自动重画 = 真
        变量 局部_临时变量 <类型 = 整数>
        变量 局部_计次 <类型 = 整数>
        画板1.画笔粗细 = 1
        画板1.画笔类型 = 画笔类型.点线
        画板1.画笔颜色 = 取颜色值 (146, 0, 0)
        循环 (画板1.高度 / 2, 0, 局部_计次, -72)
        {
            画板1.画直线 (0, 局部_计次, 画板1.宽度 - 40, 局部_计次)
            画板1.文本颜色 = 颜色类.红色
            如果真 (局部_临时变量 != 0)
            {
                画板1.定位写出 (画板1.宽度 - 40, 局部_计次 - 画板1.取高度 ("1") / 2, 数值到格式文本 (四舍五入 (成员_昨日收盘价 * (100 + 局部_临时变量) / 100, 2), 2, 假))

            }
            局部_临时变量 = 局部_临时变量 + 2

        }
        局部_临时变量 = 0
        循环 (0, (画板1.高度 - 40) / 2, 局部_计次, 72)
        {
            画板1.画直线 (0, 画板1.高度 / 2 + 局部_计次, 画板1.宽度 - 40, 画板1.高度 / 2 + 局部_计次)
            画板1.文本颜色 = 颜色类.绿色
            如果真 (局部_临时变量 != 0)
            {
                画板1.定位写出 (画板1.宽度 - 40, 画板1.高度 / 2 + 局部_计次 - 画板1.取高度 ("1") / 2, 数值到格式文本 (四舍五入 (成员_昨日收盘价 * (100 - 局部_临时变量) / 100, 2), 2, 假))
            }
            局部_临时变量 = 局部_临时变量 + 2

        }
        画板1.画笔粗细 = 2
        画板1.画笔类型 = 画笔类型.直线
        画板1.画直线 (0, 21, 画板1.宽度 - 40, 21)
        画板1.画直线 (画板1.宽度 - 45, 0, 画板1.宽度 - 45, 画板1.高度)
        画板1.画直线 (0, 画板1.高度 - 20 - 1, 画板1.宽度 - 40, 画板1.高度 - 20 - 1)
        画板1.画笔粗细 = 1
        画板1.画笔颜色 = 颜色类.银白色
        画板1.文本颜色 = 颜色类.白色
        画板1.画直线 (0, 画板1.高度 / 2, 画板1.宽度 - 40, 画板1.高度 / 2)
        画板1.定位写出 (画板1.宽度 - 40, 画板1.高度 / 2 - 画板1.取高度 ("1") / 2, 数值到格式文本 (四舍五入 (成员_昨日收盘价, 2), 2, 假))

    }

    方法 时钟_周期事件 <接收事件 类型 = 整数 注释 = "每当经过了指定的时钟周期,将发送本事件.">
    参数 来源对象 <类型 = 时钟 注释 = "提供事件产生的具体来源对象">
    参数 标记值 <类型 = 整数 注释 = "用户调用\"挂接事件\"命令时所提供的\"标记值\"参数值,非此方式挂接事件则本参数值固定为0.">
    {
        变量 局部_计次 <静态 类型 = 整数>
        变量 局部_开盘价 <类型 = 小数>
        变量 局部_收盘价 <类型 = 小数>
        变量 局部_最低价 <类型 = 小数>
        变量 局部_最高价 <类型 = 小数>
        变量 局部_开盘价位置 <类型 = 小数>
        变量 局部_收盘价位置 <类型 = 小数>
        变量 局部_最低价位置 <类型 = 小数>
        变量 局部_最高价位置 <类型 = 小数>
        变量 局部_JSON对象 <类型 = JSON对象类>
        如果真 (局部_计次 == 48)
        {
            局部_计次 = 0
            画板1.清除 ()
            方法_画框架 ()

        }
        局部_计次 = 局部_计次 + 1
        成员_JSON数组.取对象值 (局部_计次 - 1, 局部_JSON对象)
        局部_开盘价 = 文本到小数 (局部_JSON对象.取文本值 ("open"))
        局部_收盘价 = 文本到小数 (局部_JSON对象.取文本值 ("close"))
        局部_最低价 = 文本到小数 (局部_JSON对象.取文本值 ("low"))
        局部_最高价 = 文本到小数 (局部_JSON对象.取文本值 ("high"))
        画板1.画笔粗细 = 2
        如果 (局部_开盘价 < 局部_收盘价)
        {
            画板1.画笔颜色 = 颜色类.红色
            画板1.刷子颜色 = 颜色类.黑色
        }
        否则
        {
            画板1.画笔颜色 = 颜色类.艳青色
            画板1.刷子颜色 = 颜色类.艳青色
        }

        局部_开盘价位置 = (局部_开盘价 - 成员_昨日收盘价) * (画板1.高度 - 50) / 2.0 / (成员_昨日收盘价 * 0.1)
        局部_最低价位置 = (局部_最低价 - 成员_昨日收盘价) * (画板1.高度 - 50) / 2.0 / (成员_昨日收盘价 * 0.1)
        局部_最高价位置 = (局部_最高价 - 成员_昨日收盘价) * (画板1.高度 - 50) / 2.0 / (成员_昨日收盘价 * 0.1)
        局部_收盘价位置 = (局部_收盘价 - 成员_昨日收盘价) * (画板1.高度 - 50) / 2.0 / (成员_昨日收盘价 * 0.1)
        如果真 (局部_开盘价位置 == 局部_收盘价位置)
        {
            局部_收盘价位置 = 局部_开盘价位置 + 1
        }

        画板1.画直线 ((整数)((画板1.宽度 - 60) / 成员_JSON数组.成员数 * 局部_计次), (整数)(画板1.高度 / 2.0 - 局部_最低价位置), (整数)((画板1.宽度 - 60) / 成员_JSON数组.成员数 * 局部_计次), (整数)(画板1.高度 / 2.0 - 局部_最高价位置))
        画板1.画矩形 ((整数)((画板1.宽度 - 60) / 成员_JSON数组.成员数 * 局部_计次 - 3), (整数)(画板1.高度 / 2.0 - 局部_开盘价位置), (整数)((画板1.宽度 - 60) / 成员_JSON数组.成员数 * 局部_计次 + 4), (整数)(画板1.高度 / 2.0 - 局部_收盘价位置))
        返回 (0)
    }
}

【分隔符】


###### 以下为一个火山软件开发平台系统类库程序的内容

<火山程序 类型 = "通常" 版本 = 1 />

包 火山.样例

类 启动类 <公开 基础类 = 窗口程序类>
{
    变量 线程池1 <类型 = 火山线程池>

    方法 启动方法 <公开 类型 = 整数>
    {
        线程池1.启动 ()
        延时 (10000)
        计次循环 (200000)
        {
            变量 数据 <类型 = 自定义数据>
            数据.成员1 = 取循环索引 ()
            数据.成员2.分配字节集 (10000)
            线程池1.新建任务 (数据)
        }
        返回 (1)
    }

    方法 火山线程池_执行任务 <接收事件 类型 = 整数>
    参数 来源对象 <类型 = 火山线程池 注释 = "提供事件产生的具体来源对象">
    参数 标记值 <类型 = 整数 注释 = "用户调用\"挂接事件\"命令时所提供的\"标记值\"参数值,非此方式挂接事件则本参数值固定为0.">
    参数 用户对象 <类型 = 对象类>
    {
        延时 (15)    //使调试输出正常执行
        调试输出 (((自定义数据)用户对象).成员1)
        返回 (0)
    }
}

类 自定义数据 <公开>
{
    变量 成员1 <公开 类型 = 整数>
    变量 成员2 <公开 类型 = 字节集类>
}

类 火山线程池 <公开 基础类 = HP线程池类>
{
    方法 线程函数 <静态 注释 = "提供线程执行函数的模板方法.">
    参数 用户数据 <类型 = 变整数 注释 = "在提交任务时所提供的用户数据参数.">
    {
        读指针处对象 (读指针处对象 (用户数据, 对象类).标记值, 火山线程池).事件执行 (读指针处对象 (用户数据, 对象类))
    }

    方法 新建任务 <公开 类型 = 逻辑型 返回值注释 = "返回线程是否新建成功">
    参数 用户对象 <类型 = 对象类>
    {
        变量 提交数据 <类型 = 变整数>
        用户对象.标记值 = 取本对象地址 ()
        提交数据 = 取副本指针 (用户对象)
        如果 (提交任务 (线程函数, 提交数据) == 假)
        {
            释放副本 (提交数据)
            返回 (假)
        }
        返回 (真)
    }

    方法 事件执行
    参数 用户对象 <类型 = 对象类>
    {
        执行任务 (用户对象)
        释放对象 (用户对象)
    }

    方法 执行任务 <公开 定义事件 类型 = 整数>
    参数 用户对象 <类型 = 对象类>

    方法 取本对象地址 <公开 类型 = 变整数 @嵌入式方法 = "">
    {
        @ (INT_P)this
    }

    方法 取副本指针 <类型 = 变整数 @嵌入式方法 = "">
    参数 对象 <类型 = 对象类>
    {
        @ (INT_P)@<对象>.MakeCloneObject()
    }

    方法 释放副本 <@嵌入式方法 = "">
    参数 指针 <类型 = 变整数>
    {
        @ ((CVolObject*)@<指针>)->Destroy()
    }

    方法 释放对象 <@嵌入式方法 = "">
    参数 对象 <类型 = 对象类>
    {
        @ @<对象>.Destroy()
    }
}

【分隔符】


###### 以下为一个火山软件开发平台系统类库程序的内容

<火山程序 类型 = "通常" 版本 = 1 />

包 火山.利快云教育培训 <注释 = "利快云资源：https://www.lkuaiy.com/">

类 启动类 <公开 基础类 = 窗口程序类>
{
    变量 主窗口 <类型 = 我的主窗口>

    方法 启动方法 <公开 类型 = 整数 注释 = "利快云资源：https://www.lkuaiy.com/">
    {
        主窗口.创建主窗口 ()
        返回 (1)
    }
}

# ===

类 我的主窗口 <基础类 = 窗口 注释 = "利快云资源：https://www.lkuaiy.com/" 隐藏值属性 = "0"
        @视窗.布局 = "client_size = \"312, 222\"">
{
    变量 按钮1 <类型 = 按钮 隐藏值属性 = "0" @视窗.布局 = "id = 101\r\npos = \"85, 46, 152, 48\"" 标题 = "写文本文件">
    变量 按钮2 <类型 = 按钮 隐藏值属性 = "0" @视窗.布局 = "id = 102\r\npos = \"86, 102, 152, 48\"" 标题 = "读文本文件">

    方法 按钮_被单击 <接收事件 类型 = 整数 注释 = "当按钮被单击后发送此事件">
    参数 来源对象 <类型 = 按钮 注释 = "提供事件产生的具体来源对象">
    参数 标记值 <类型 = 整数 注释 = "用户调用\"挂接事件\"命令时所提供的\"标记值\"参数值,非此方式挂接事件则本参数值固定为0.">
    {
        如果 (来源对象 == 按钮1)
        {
            写出文本文件 ("测试", "D:\\测试\\11.txt", , 文本编码类型.多字节)
            // 多字节也就是ansi编码
        }
        否则 (来源对象 == 按钮2)
        {
            信息框 (读入文本文件 ("D:\\测试\\11.txt", , 文本编码类型.多字节))
            // 保存用什么,读取用同样的。
        }
        返回 (0)
    }
}
