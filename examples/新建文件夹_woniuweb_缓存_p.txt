
###### 以下为一个火山软件开发平台系统类库程序的内容

<火山程序 类型 = "通常" 版本 = 1 />

包 蜗牛服务器.缓存

类 缓存数据
{
    变量 m_互斥锁 <公开 类型 = 互斥锁类>
    变量 m_哈希数组 <类型 = 整数数组类>
    变量 m_主键数组 <公开 类型 = 文本数组类>
    变量 m_内容数组 <类型 = 文本数组类>
    变量 m_使用时间数组 <类型 = 整数数组类>
    变量 m_过期时间数组 <类型 = 整数数组类>

    方法 清理事件 <公开 定义事件 类型 = 整数>
    参数 清理主键 <类型 = 文本型>
    参数 清理内容 <类型 = 文本型>
    {

    }

    方法 清理超时缓存 <公开>
    {
        __清理超时缓存 (本对象, m_互斥锁, m_哈希数组, m_主键数组, m_内容数组, m_使用时间数组, m_过期时间数组)
    }

    方法 __清理超时缓存 <静态>
    参数 缓存数据对象 <类型 = 缓存数据>
    参数 互斥锁 <类型 = 互斥锁类>
    参数 哈希数组 <类型 = 整数数组类>
    参数 主键数组 <类型 = 文本数组类>
    参数 内容数组 <类型 = 文本数组类>
    参数 使用时间数组 <类型 = 整数数组类>
    参数 过期时间数组 <类型 = 整数数组类>
    {
        变量 成员数 <类型 = 整数>
        变量 i <类型 = 整数>
        变量 经历秒数 <类型 = 整数>
        变量 清理主键数组 <类型 = 文本数组类>
        变量 清理内容数组 <类型 = 文本数组类>
        经历秒数 = 取经历秒数 ()
        互斥锁.加锁 ()
        成员数 = 使用时间数组.取成员数 ()
        循环 (成员数 - 1, -1, i, -1)
        {
            如果 (经历秒数 - 使用时间数组.取成员 (i) > 过期时间数组.取成员 (i))  // 超时啦...
            {
                变量 被清理的主键 <类型 = 文本型>
                变量 被清理的内容 <类型 = 文本型>
                被清理的主键 = 主键数组.取成员 (i)
                被清理的内容 = 内容数组.取成员 (i)
                清理主键数组.加入成员 (被清理的主键)
                清理内容数组.加入成员 (被清理的内容)
                哈希数组.删除成员 (i)
                主键数组.删除成员 (i)
                内容数组.删除成员 (i)
                使用时间数组.删除成员 (i)
            }
        }

        互斥锁.解锁 ()
        循环 (0, 清理主键数组.取成员数 (), i)
        {
            缓存数据对象.清理事件 (清理主键数组.取成员 (i), 清理内容数组.取成员 (i))
        }


    }

    方法 是否存在 <公开 类型 = 逻辑型>
    参数 主键 <类型 = 文本型>
    {
        变量 索引 <类型 = 整数>
        变量 哈希值 <类型 = 整数>
        哈希值 = 取文本哈希值 (主键)
        m_互斥锁.加锁 ()
        索引 = __取索引 (哈希值, 主键, m_哈希数组, m_主键数组, m_使用时间数组, 假)

        m_互斥锁.解锁 ()
        返回 (索引 != -1)
    }

    方法 计次加 <公开 类型 = 整数>
    参数 主键 <类型 = 文本型>
    参数 过期时间 <类型 = 整数>
    {
        变量 索引 <类型 = 整数>
        变量 哈希值 <类型 = 整数>
        变量 返回值 <类型 = 整数>
        哈希值 = 取文本哈希值 (主键)
        m_互斥锁.加锁 ()
        索引 = __取索引 (哈希值, 主键, m_哈希数组, m_主键数组, m_使用时间数组, 假)
        如果 (索引 == -1)  // 不存在的主键!
        {
            m_哈希数组.加入成员 (哈希值)
            m_主键数组.加入成员 (主键)
            m_内容数组.加入成员 ("1")
            m_使用时间数组.加入成员 (取经历秒数 ())
            m_过期时间数组.加入成员 (过期时间)
            返回 (1)
        }
        返回值 = 文本到整数 (m_内容数组.取成员 (索引)) + 1
        m_内容数组.置成员值 (索引, 到文本 (返回值))
        m_互斥锁.解锁 ()
        返回 (返回值)

    }

    方法 置文本 <公开 类型 = 逻辑型>
    参数 主键 <类型 = 文本型>
    参数 文本 <类型 = 文本型>
    参数 过期时间 <类型 = 整数 注释 = "单位:秒..">
    {
        变量 哈希值 <类型 = 整数>
        变量 索引 <类型 = 整数>
        变量 秒数 <类型 = 整数>
        哈希值 = 取文本哈希值 (主键)
        秒数 = 取经历秒数 ()

        m_互斥锁.加锁 ()
        索引 = __取索引 (哈希值, 主键, m_哈希数组, m_主键数组, m_使用时间数组, 真)
        如果 (索引 == -1)  // 不存在,直接加入...
        {
            m_哈希数组.加入成员 (哈希值)
            m_主键数组.加入成员 (主键)
            m_内容数组.加入成员 (文本)
            m_使用时间数组.加入成员 (秒数)
            m_过期时间数组.加入成员 (过期时间)
            m_互斥锁.解锁 ()
            返回 (真)
        }
        m_内容数组.置成员值 (索引, 文本)
        m_使用时间数组.置成员值 (索引, 秒数)
        m_过期时间数组.置成员值 (索引, 过期时间)
        m_互斥锁.解锁 ()
        返回 (真)

    }

    方法 取文本 <公开 类型 = 文本型>
    参数 主键 <类型 = 文本型>
    参数 是否续期 <类型 = 逻辑型>
    {
        变量 哈希值 <类型 = 整数>
        变量 返回值 <类型 = 文本型>
        变量 索引 <类型 = 整数>
        哈希值 = 取文本哈希值 (主键)
        m_互斥锁.加锁 ()
        索引 = __取索引 (哈希值, 主键, m_哈希数组, m_主键数组, m_使用时间数组, 是否续期)
        如果 (索引 == -1)
        {
            m_互斥锁.解锁 ()
            返回 ("")
        }
        返回值 = m_内容数组.取成员 (索引)
        m_互斥锁.解锁 ()
        返回 (返回值)
    }

    方法 __取索引 <静态 类型 = 整数 注释 = "-1 代表不存在!">
    参数 哈希值 <类型 = 整数>
    参数 主键 <类型 = 文本型>
    参数 哈希数组 <类型 = 整数数组类>
    参数 主键数组 <类型 = 文本数组类>
    参数 使用时间数组 <类型 = 整数数组类>
    参数 是否续期 <类型 = 逻辑型>
    {
        变量 成员数 <类型 = 整数>
        变量 i <类型 = 整数>
        成员数 = 哈希数组.取成员数 ()
        循环 (0, 成员数, i)
        {
            如果 (哈希数组.取成员 (i) == 哈希值 && 主键数组.取成员 (i) == 主键)
            {
                如果 (是否续期)
                {
                    使用时间数组.置成员值 (i, 取经历秒数 ())
                }
                返回 (i)
            }

        }
        返回 (-1)
    }

    #
}

类 w_缓存对象 <公开 注释 = "多线程安全对象">
{
    变量 m_缓存数据 <类型 = "缓存数据 [2000]">
    变量 m_上次清理时间 <类型 = "原子整数类 [2000]" 注释 = "记录 秒">

    方法 _清理超时缓存
    参数 索引 <类型 = 整数>
    {
        变量 经历秒数 <类型 = 整数>
        经历秒数 = 取经历秒数 ()
        如果 (m_上次清理时间 [索引].取值 () == 经历秒数)  // 这一秒,已经清理了...下次再来了...
        {
            返回
        }
        m_上次清理时间 [索引].置值 (经历秒数)
        m_缓存数据 [索引].清理超时缓存 ()

    }

    方法 主动清理超时缓存 <公开 注释 = "一般情况下不需要调用此方法...">
    {
        变量 i <类型 = 整数>
        循环 (0, 取数组成员数 (m_缓存数据), i)
        {
            _清理超时缓存 (i)
        }
    }

    方法 取所有主键 <公开 类型 = 整数 返回值注释 = "返回成员数">
    参数 返回主键数组 <类型 = 文本数组类>
    {
        变量 i <类型 = 整数>
        返回主键数组.删除所有成员 ()
        循环 (0, 取数组成员数 (m_缓存数据), i)
        {
            _清理超时缓存 (i)  // 先清理超时的缓存!
            m_缓存数据 [i].m_互斥锁.加锁 ()
            返回主键数组.添加数组 (m_缓存数据 [i].m_主键数组)
            m_缓存数据 [i].m_互斥锁.解锁 ()
        }
        返回 (返回主键数组.取成员数 ())
    }

    方法 是否存在 <公开 类型 = 逻辑型>
    参数 主键 <类型 = 文本型>
    {
        变量 索引 <类型 = 整数>
        索引 = w_文本_取索引 (主键, 取数组成员数 (m_上次清理时间))
        _清理超时缓存 (索引)
        返回 (m_缓存数据 [索引].是否存在 (主键))
    }

    方法 置文本 <公开 类型 = 逻辑型 返回值注释 = "直接返回真...">
    参数 主键 <类型 = 文本型>
    参数 文本内容 <类型 = 文本型>
    参数 过期时间 <类型 = 整数 注释 = "单位:秒">
    {
        变量 索引 <类型 = 整数>
        索引 = w_文本_取索引 (主键, 取数组成员数 (m_上次清理时间))
        _清理超时缓存 (索引)
        返回 (m_缓存数据 [索引].置文本 (主键, 文本内容, 过期时间))
    }

    方法 取文本 <公开 类型 = 文本型>
    参数 主键 <类型 = 文本型>
    参数 当前主键缓存是否续期 <类型 = 逻辑型>
    {
        变量 索引 <类型 = 整数>
        索引 = w_文本_取索引 (主键, 取数组成员数 (m_上次清理时间))
        _清理超时缓存 (索引)
        返回 (m_缓存数据 [索引].取文本 (主键, 当前主键缓存是否续期))
    }

    方法 清理缓存事件 <公开 定义事件 类型 = 整数 注释 = "清理后触发,所以,您如果判断\"被清理的主键\"是否存在,会返回假!">
    参数 被清理的主键 <类型 = 文本型>
    参数 被清理的内容 <类型 = 文本型>
    {


    }

    方法 缓存数据_清理事件 <接收事件 类型 = 整数>
    参数 来源对象 <类型 = 缓存数据 注释 = "提供事件产生的具体来源对象">
    参数 标记值 <类型 = 整数 注释 = "用户调用\"挂接事件\"命令时所提供的\"标记值\"参数值,非此方式挂接事件则本参数值固定为0.">
    参数 清理主键 <类型 = 文本型>
    参数 清理内容 <类型 = 文本型>
    {
        本对象.清理缓存事件 (清理主键, 清理内容)
        返回 (0)
    }
}
